#!/bin/bash

#----------------------------START: Common Function----------------------------

function escapejc() { # Escape string for use with Curl-JSON
    # echo '{"foo":"bar"}'| sed s/\"/'\\\"'/g
    input_string="$1"
    output_string=$(echo "${input_string}" | sed s/'\\'/'\\\\\\\\'/g | sed s/\"/'\\\\\\"'/g) # Escapes double-quote(" and \") and backslash(\) for Curl
    if [[ "$OSTYPE" == 'msys' ]]
    then
        if [[ ${output_string:0:2} == '//' ]]
        then
            output_string="${output_string:1}"
        fi
    fi
    echo "${output_string}"
}

function escape_single_quote() {
    input_string="$1"
    output_string=$(echo "${input_string}" | sed s/\'/"'\\\\\\\''"/g)
    echo "${output_string}"
}

function unix2win_path() {
    input_path="$1"
    output_path=$(echo "${input_path}" | sed -e 's/^\///' -e 's/\//\\/g' -e 's/^./\0:/')
    echo "${output_path}"
}

function gum_path() {
    input_string="$1"
    if [[ "$OSTYPE" == 'msys' ]]
    then
        if [[ ${input_string:0:1} == '/' ]]
        then
            output_string="/${input_string}"
            echo "${output_string}"
        else
            echo "${input_string}"
        fi
    else
        echo "${input_string}"
    fi
}

#----------------------------END: Common Function----------------------------

#----------------------------START: BASH TABLE----------------------------
# GitHub Repository: https://github.com/jakobwesthoff/prettytable.sh

_prettytable_char_top_left="┌"
_prettytable_char_horizontal="─"
_prettytable_char_vertical="│"
_prettytable_char_bottom_left="└"
_prettytable_char_bottom_right="┘"
_prettytable_char_top_right="┐"
_prettytable_char_vertical_horizontal_left="├"
_prettytable_char_vertical_horizontal_right="┤"
_prettytable_char_vertical_horizontal_top="┬"
_prettytable_char_vertical_horizontal_bottom="┴"
_prettytable_char_vertical_horizontal="┼"


# Escape codes

# Default colors
_prettytable_color_blue="0;34"
_prettytable_color_green="0;32"
_prettytable_color_cyan="0;36"
_prettytable_color_red="0;31"
_prettytable_color_purple="0;35"
_prettytable_color_yellow="0;33"
_prettytable_color_gray="1;30"
_prettytable_color_light_blue="1;34"
_prettytable_color_light_green="1;32"
_prettytable_color_light_cyan="1;36"
_prettytable_color_light_red="1;31"
_prettytable_color_light_purple="1;35"
_prettytable_color_light_yellow="1;33"
_prettytable_color_light_gray="0;37"

# Somewhat special colors
_prettytable_color_black="0;30"
_prettytable_color_white="1;37"
_prettytable_color_none="0"

function _prettytable_prettify_lines() {
    cat - | sed -e "s@^@${_prettytable_char_vertical}@;s@\$@	@;s@	@	${_prettytable_char_vertical}@g"
}

function _prettytable_fix_border_lines() {
    cat - | sed -e "1s@ @${_prettytable_char_horizontal}@g;3s@ @${_prettytable_char_horizontal}@g;\$s@ @${_prettytable_char_horizontal}@g"
}

function _prettytable_colorize_lines() {
    local color="$1"
    local range="$2"
    local ansicolor="$(eval "echo \${_prettytable_color_${color}}")"

    cat - | sed -e "${range}s@\\([^${_prettytable_char_vertical}]\\{1,\\}\\)@"$'\E'"[${ansicolor}m\1"$'\E'"[${_prettytable_color_none}m@g"
}

function prettytable() {
    local cols="${1}"
    local color="${2:-none}"
    local input="$(cat -)"
    local header="$(echo -e "${input}"|head -n1)"
    local body="$(echo -e "${input}"|tail -n+2)"
    {
        # Top border
        echo -n "${_prettytable_char_top_left}"
        for i in $(seq 2 ${cols}); do
            echo -ne "\t${_prettytable_char_vertical_horizontal_top}"
        done
        echo -e "\t${_prettytable_char_top_right}"

        echo -e "${header}" | _prettytable_prettify_lines

        # Header/Body delimiter
        echo -n "${_prettytable_char_vertical_horizontal_left}"
        for i in $(seq 2 ${cols}); do
            echo -ne "\t${_prettytable_char_vertical_horizontal}"
        done
        echo -e "\t${_prettytable_char_vertical_horizontal_right}"

        echo -e "${body}" | _prettytable_prettify_lines

        # Bottom border
        echo -n "${_prettytable_char_bottom_left}"
        for i in $(seq 2 ${cols}); do
            echo -ne "\t${_prettytable_char_vertical_horizontal_bottom}"
        done
        echo -e "\t${_prettytable_char_bottom_right}"
    } | column -t -s $'\t' | _prettytable_fix_border_lines | _prettytable_colorize_lines "${color}" "2"
}

#----------------------------END: BASH TABLE----------------------------

overall_help_text="config || Configuration, repository and download management\n
rsgit || \"restic-git\". Does restic and git based backup.\n
rsdrive || \"restic-drive\". Does restic backup on Portable Storage Device.\n
rssync || \"sync-restic-repo\". Sync online restic repo to local-pc restic repo.\n
rsrestore || \"restore-restic-git\". Restore single/all restic and git repository.\n
gist || \"gist\". GitHub-Gist management script.\n
note || \"pjnote\". Project's markdown-note management script.\n
todo || \"pjtodo\". Project's ToDo management script.\n
dbsync || \"db-sync\". Sync database between online and local-pc in bi-directional way.\n
dbackup || \"dbackup\". Backup database structure, data, full-db for git commit.\n
pcsync || Sync data among pc, mobile and storage.\n
cmd || Command reference management.\n
exit || Exit script."

# Follow "rclone" and "mkdocs" style help manual
function help_overall() {
  printf "Usage:\njjkk [command]\n\nAvailabe Commands:\n"
  printf "${overall_help_text}" | column --table --separator "||"
}

if [[ "$1" == 'help' ]]
then
  help_overall
  exit
fi

declare -a DOWNLOAD_ID_COLL # ID collection of Downloads, to use with for-loop. "-a"=Indexed_Array
declare -a PROJECT_ID_COLL # ID collection of Projects, to use with for-loop. "-a"=Indexed_Array
declare -a TODO_ID_COLL # ID collection of ToDo, to use with for-loop. "-a"=Indexed_Array
declare -a DEVICE_ID_COLL # ID collection of Devices, to use with for-loop. "-a"=Indexed_Array
declare -a TASK_ID_COLL # ID collection of Tasks, to use with for-loop. "-a"=Indexed_Array
declare -A restic_repo_list # "-A"=Associative_Array
declare -A git_repo_list
declare -A all_repo_list
declare -A note_repo_list
declare -A download_list

repo_file_path="/c/ProgramData/snb/backup-n-sync-config"
repo_json_file="${repo_file_path}/repository-list.json"
source "${repo_file_path}/sync-gapps-url"

base_config_data=$(cat "${repo_json_file}" | jq -r '.repo_config|to_entries|.[1:29]|map("\(.key)='\''\(.value)'\''")|.[]')

repo_config_data=$(cat "${repo_json_file}" | jq -r '.restic_git_repo|map("
if [[ '\''\(.sync_type)'\'' == '\''restic-only'\'' || '\''\(.sync_type)'\'' == '\''restic-git'\'' ]]; then
restic_repo_list['\''\(.pwd)'\'']='\''\(.restic_address) \(.restic_password) \(.restic_type) \(.rclone_name) \(.workstation_type) \(.workstation_name) \(.sync_type)'\'';
fi
if [[ '\''\(.sync_type)'\'' == '\''git-only'\'' || '\''\(.sync_type)'\'' == '\''restic-git'\'' ]]; then
git_repo_list['\''\(.pwd)'\'']='\''\(.git_url) \(.rclone_name) \(.composer_download) \(.npm_download) \(.database_name)'\'';
fi
all_repo_list['\''\(.pwd)'\'']='\''\(.id) \(.git_url) \(.rclone_name) \(.composer_download) \(.npm_download) \(.database_name) \(.restic_address) \(.restic_password) \(.restic_type) \(.workstation_type) \(.workstation_name) \(.sync_type) \(.note_path_id)'\'';
note_repo_list['\''\(.pwd)'\'']='\''\(.note_path_id)'\'';
")|.[]')

download_config_data=$(cat "${repo_json_file}" | jq -r '.download|map("
download_list['\''\(.id),id'\'']='\''\(.id)'\'';
download_list['\''\(.id),type'\'']='\''\(.type)'\'';
download_list['\''\(.id),name'\'']='\''\(.name)'\'';
download_list['\''\(.id),url'\'']='\''\(.url)'\'';
DOWNLOAD_ID_COLL+=('\''\(.id)'\'');
")|.[]')

eval "${base_config_data}"
eval "${repo_config_data}"
eval "${download_config_data}"

    # echo -e "Repo config values are: \n git_uncommitted_sync_remote_base='${git_uncommitted_sync_remote_base}';\n database_sync_remote_base='${database_sync_remote_base}';\n db_sync_local_base_path='${db_sync_local_base_path}';\n db_archive_base_path='${db_archive_base_path}';\n enable_db_archive='${enable_db_archive}';\n db_host_name='${db_host_name}';\n windows_editor='${windows_editor}';\n linux_editor='${linux_editor}';\n restore_restic_git_base_path='${restore_restic_git_base_path}';\n sync_restic_repo_base_path='${sync_restic_repo_base_path}';\n sync_restic_repo_password='${sync_restic_repo_password}';\n desktop_exclude_base_path='${desktop_exclude_base_path}';\n server_exclude_base_path='${server_exclude_base_path}';\n project_drive_path='${project_drive_path}';\n document_drive_path='${document_drive_path}';\n project_drive_repo_name='${project_drive_repo_name}';\n document_drive_repo_name='${document_drive_repo_name}';\n project_drive_psd_identification='${project_drive_psd_identification}';\n document_drive_psd_identification='${document_drive_psd_identification}';\n drive_restic_repo_password='${drive_restic_repo_password}';\n gist_list_limit='${gist_list_limit}';\n max_gist_create='${max_gist_create}';\n gist_temporary_file='${gist_temporary_file}';\n gist_temporary_folder='${gist_temporary_folder}';\n note_base_path='${note_base_path}';"

    # echo "Values of 'restic_repo_list' array: " >> "${repo_file_path}/test.txt"
    # for restic_repo_inc in "${!restic_repo_list[@]}"
    # do
    #   echo "restic_repo_list['${restic_repo_inc}']='${restic_repo_list[$restic_repo_inc]}'" >> "${repo_file_path}/test.txt"
    # done

    # echo "Values of 'git_repo_list' array: " >> "${repo_file_path}/test.txt"
    # for git_repo_inc in "${!git_repo_list[@]}"
    # do
    #   echo "git_repo_list['${git_repo_inc}']='${git_repo_list[$git_repo_inc]}'" >> "${repo_file_path}/test.txt"
    # done

#----------------------------START: Configuration----------------------------

config_help_text="rbase || Repository base config management.\n
repo || Restic and Git repository management.\n
download || Download info management.\n
import || Import config management."

config_rbase_help="list || Shows all repo base config.\n
edit || Edit existing repo base config.\n
notep || Note Base Path - add, view, edit, delete.\n"

config_repo_help="view || View a repo from all repo list.\n
add || Add new repository.\n
edit || Edit existing repository.\n
delete || Delete existing repository."

config_download_help="view || View download info from all download list.\n
add || Add new download info.\n
edit || Edit existing download info.\n
delete || Delete existing download info."

config_import_help="notep || Import Note Base Path.\n
repo || Import repository details.\n
download || Import download info."

function help_config() {
    printf "Usage:\njjkk config [command]\n\nAvailabe Commands:\n"
    printf "${config_help_text}" | column --table --separator "||"
    printf "\nRepo Base Config Management Commands:\n"
    printf "${config_rbase_help}" | column --table --separator "||"
    printf "\nRepository Management Commands:\n"
    printf "${config_repo_help}" | column --table --separator "||"
    printf "\nDownload Management Commands:\n"
    printf "${config_download_help}" | column --table --separator "||"
    printf "\nImport Config Management Commands:\n"
    printf "${config_import_help}" | column --table --separator "||"
}

function rbase_list_config() {
    echo "Base Information ->"
    show_base_info="
    KEY|[}|VALUE\n
    git_uncommitted_sync_remote_base|[}|${git_uncommitted_sync_remote_base}\n
    database_sync_remote_base|[}|${database_sync_remote_base}\n
    db_sync_local_base_path|[}|${db_sync_local_base_path}\n
    db_archive_base_path|[}|${db_archive_base_path}\n
    enable_db_archive|[}|${enable_db_archive}\n
    db_host_name|[}|${db_host_name}\n
    windows_editor|[}|${windows_editor}\n
    linux_editor|[}|${linux_editor}\n
    restore_restic_git_base_path|[}|${restore_restic_git_base_path}\n
    sync_restic_repo_base_path|[}|${sync_restic_repo_base_path}\n
    sync_restic_repo_password|[}|${sync_restic_repo_password}\n
    desktop_exclude_base_path|[}|${desktop_exclude_base_path}\n
    server_exclude_base_path|[}|${server_exclude_base_path}\n
    project_drive_path|[}|${project_drive_path}\n
    document_drive_path|[}|${document_drive_path}\n
    project_drive_repo_name|[}|${project_drive_repo_name}\n
    document_drive_repo_name|[}|${document_drive_repo_name}\n
    drive_restic_repo_password|[}|${drive_restic_repo_password}\n
    gist_list_limit|[}|${gist_list_limit}\n
    max_gist_create|[}|${max_gist_create}\n
    gist_temporary_file|[}|${gist_temporary_file}\n
    gist_temporary_folder|[}|${gist_temporary_folder}\n
    command_reference_file|[}|${command_reference_file}\n
    download_location|[}|${download_location}\n
    "
    printf "${show_base_info}" | column --table --separator "|[}|"
    echo "    project_drive_psd_identification" "      " $(echo ${project_drive_psd_identification} | jq -R)
    echo "    document_drive_psd_identification" "     " $(echo ${document_drive_psd_identification} | jq -R)

    echo -e "\n    Note Base Path:"
    total_note_base_path=$(cat "${repo_json_file}" | jq '.repo_config .note_base_path_collection | length')
    for((counter=0; counter < $total_note_base_path; ++counter)) do
        each_note_base_path=$(cat "${repo_json_file}" | jq ".repo_config .note_base_path_collection[${counter}]")
        echo "         (${counter})" $(echo ${each_note_base_path} | jq -r '.note_base_path')
    done
}

function rbase_edit_config() {
    rbase_key_list="git_uncommitted_sync_remote_base\ndatabase_sync_remote_base\ndb_sync_local_base_path\ndb_archive_base_path\nenable_db_archive\ndb_host_name\nwindows_editor\nlinux_editor\nrestore_restic_git_base_path\nsync_restic_repo_base_path\nsync_restic_repo_password\ndesktop_exclude_base_path\nserver_exclude_base_path\nproject_drive_path\ndocument_drive_path\nproject_drive_repo_name\ndocument_drive_repo_name\nproject_drive_psd_identification\ndocument_drive_psd_identification\ndrive_restic_repo_password\ngist_list_limit\nmax_gist_create\ngist_temporary_file\ngist_temporary_folder\ncommand_reference_file\ndownload_location"
    selected_key=$(echo -e ${rbase_key_list} | gum filter --indicator=">" --header="Select Repository Base Info To Edit")
    
    get_key_value=$(cat "${repo_json_file}" | jq -r ".repo_config .${selected_key}")
    key_value_input=$(gum write --header="Enter value for ${selected_key}" --placeholder="Write value for ${selected_key}" --value="${get_key_value}")
    dasel put -f "${repo_json_file}" -r json -t string -v "${key_value_input}" "repo_config.${selected_key}"
    echo -e "\033[1;32m Repo Base Info Updated Successfully. \033[0m"
}

function rbase_note_path_config() {
    note_action=$(gum choose --header="Select Action for Note-Base-Path" "add" "edit" "delete")
    if [[ ${note_action} == "add" ]]
    then
        note_path_input=$(gum input --header="Enter Note Base Path To Add" --placeholder="Write Note Base Path")
        total_note_base_path=$(cat "${repo_json_file}" | jq '.repo_config .note_base_path_collection | length')
        for((note_counter=0; note_counter < ${total_note_base_path}; ++note_counter)) do
            each_note_base_path=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_counter}] .note_base_path")
            if [[ "${note_path_input}" == "${each_note_base_path}" ]]
            then
                echo -e "\033[1;31m Note Base Path Already Exists! \033[0m"
                exit
            fi
        done
        dasel put -f "${repo_json_file}" -r json -t string -v "${note_path_input}" 'repo_config.note_base_path_collection.[].note_base_path'
        echo -e "\033[1;32m Note Base Path Added Successfully. \033[0m"
        exit
    fi

    note_base_path_choose=""
    total_note_base_path=$(cat "${repo_json_file}" | jq '.repo_config .note_base_path_collection | length')
    for((note_counter=0; note_counter < ${total_note_base_path}; ++note_counter)) do
        each_note_base_path=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_counter}] .note_base_path")
        note_base_path_choose+="${note_counter}\t${each_note_base_path}\n"
    done
    note_base_path_choose=${note_base_path_choose%??}

    if [[ ${note_action} == "edit" ]]
    then
        note_path_text=$(echo -e "${note_base_path_choose}" | gum filter --indicator=">" --header="Select Note Base Path To Edit")
        note_path_array=(${note_path_text})
        note_path_id=${note_path_array[0]}
        note_path_edit=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_path_id}] .note_base_path")
        note_path_input=$(gum input --header="Enter Note Base Path To Edit" --placeholder="Write Note Base Path" --value="${note_path_edit}")
        for((note_counter=0; note_counter < ${total_note_base_path}; ++note_counter)) do
            each_note_base_path=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_counter}] .note_base_path")
            if [[ "${note_path_input}" == "${each_note_base_path}" && "${note_path_input}" != "${note_path_edit}" ]]
            then
                echo -e "\033[1;31m Note Base Path Already Exists! \033[0m"
                exit
            fi
        done
        dasel put -f "${repo_json_file}" -r json -t string -v "${note_path_input}" "repo_config.note_base_path_collection.[${note_path_id}].note_base_path"
        echo -e "\033[1;32m Note Base Path Updated Successfully. \033[0m"
        exit
    fi

    if [[ ${note_action} == "delete" ]]
    then
        note_path_text=$(echo -e "${note_base_path_choose}" | gum filter --indicator=">" --header="Select Note Base Path To Delete")
        note_path_array=(${note_path_text})
        note_path_id=${note_path_array[0]}
        note_path_delete=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_path_id}] .note_base_path")
        confirm_delete=$(gum confirm --default="No" "Delete Note Base Path: ${note_path_delete}?" && echo "yes" || echo "no")
        if [[ ${confirm_delete} == "yes" ]]
        then
            dasel delete -f "${repo_json_file}" -r json "repo_config.note_base_path_collection.[${note_path_id}]"
            echo -e "\033[1;32m Note Base Path Deleted Successfully. \033[0m"
        fi
    fi
}

function store_repo_config() {
    all_repo_string=""
    for pwd in "${!all_repo_list[@]}"; do
        repo_record=(${all_repo_list["${pwd}"]})
        all_repo_string+="${repo_record[0]}\t${pwd}\n"
    done
    all_repo_string=${all_repo_string%??}
}

function repo_list_config() {
    store_repo_config
    filtered_repo_string=$(echo -e ${all_repo_string} | gum filter --indicator=">" --header="Select Repository To View Details: ID | PWD")
    filtered_repo_array=(${filtered_repo_string})
    filtered_repo_id=${filtered_repo_array[0]}
    repo_json=$(cat "${repo_json_file}" | jq ".restic_git_repo[] | select(.id == ${filtered_repo_id})")
    echo "Repository Details ->"
    repo_show="KEY\tVALUE\n"
    repo_show+="ID\t"$(echo ${repo_json} | jq -r '.id')"\n"
    repo_show+="PWD\t"$(echo ${repo_json} | jq -r '.pwd')"\n"
    repo_show+="Git URL\t"$(echo ${repo_json} | jq -r '.git_url')"\n"
    repo_show+="Rclone Name\t"$(echo ${repo_json} | jq -r '.rclone_name')"\n"
    repo_show+="Composer Download\t"$(echo ${repo_json} | jq -r '.composer_download')"\n"
    repo_show+="NPM Download\t"$(echo ${repo_json} | jq -r '.npm_download')"\n"
    repo_show+="Database Name\t"$(echo ${repo_json} | jq -r '.database_name')"\n"
    repo_show+="Restic Address\t"$(echo ${repo_json} | jq -r '.restic_address')"\n"
    repo_show+="Restic Password\t"$(echo ${repo_json} | jq -r '.restic_password')"\n"
    repo_show+="Restic Type\t"$(echo ${repo_json} | jq -r '.restic_type')"\n"
    repo_show+="Workstation Type\t"$(echo ${repo_json} | jq -r '.workstation_type')"\n"
    repo_show+="Workstation Name\t"$(echo ${repo_json} | jq -r '.workstation_name')"\n"
    repo_show+="Sync Type\t"$(echo ${repo_json} | jq -r '.sync_type')"\n"
    note_path_id=$(echo ${repo_json} | jq -r '.note_path_id')
    repo_show+="Note Base Path\t"$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_path_id}].note_base_path")
    printf "${repo_show}" | prettytable 2
}

function repo_add_config() {
    total_repo_count=$(cat "${repo_json_file}" | jq '.restic_git_repo | length')
    if [[ ${total_repo_count} == 0 ]]
    then
        next_repo_id=1
    else
        last_repo_id=$(dasel -f "${repo_json_file}" -r json 'restic_git_repo.last().id')
        next_repo_id=$((last_repo_id+1))
    fi
    echo "Add Repository ->"
    pwd_input=$(gum input --header="Enter Present Working Directory" --placeholder="Write Present Working Directory")
    if [[ ${all_repo_list["${pwd_input}"]} != '' ]]
    then
        echo -e "\033[1;31m Present Working Directory (PWD) Already Exists! \033[0m"
        exit
    fi
    sync_type_input=$(gum choose --header="Select Sync Type" "restic-git" "git-only" "restic-only")
    
    if [[ ${sync_type_input} == "restic-only" ]]
    then
        git_url_input="N/A"
    else
        git_url_input=$(gum input --header="Enter Git URL (eg: N/A, URL)" --placeholder="Write Git URL")
    fi

    if [[ ${sync_type_input} == "git-only" ]]    
    then
        composer_download_input=$(gum choose --header="Select Composer Download" "yes" "no")
        npm_download_input=$(gum choose --header="Select NPM (Node Package Manger) Download" "yes" "no")
        database_name_input=$(gum input --header="Enter Database Name (eg: N/A, VALUE)" --placeholder="Write Database Name")
        restic_type_input="N/A"
        rclone_name_input="N/A"
        restic_address_input="N/A"
        restic_password_input="N/A"
    else
        composer_download_input="N/A"
        npm_download_input="N/A"
        database_name_input="N/A"
        restic_type_input=$(gum choose --header="Select Restic Type" "rclone" "local")
        if [[ ${restic_type_input} == "rclone" ]]
        then
            rclone_name_input=$(rclone listremotes | gum choose --header="Select Rclone Name")
        else
            rclone_name_input="N/A"
        fi
        restic_address_input=$(gum input --header="Enter Restic Address (eg: N/A, VALUE)" --placeholder="Write Restic Address")
        restic_password_input=$(gum input --header="Enter Restic Password" --placeholder="Write Restic Password")
    fi

    workstation_type_input=$(gum choose --header="Select Workstation Type" "desktop-pc" "server-pc")
    workstation_name_input=$(gum input --header="Enter Workstation Name (eg: desktop, server)" --placeholder="Write Workstation Name")
    note_base_path_choose=""
    total_note_base_path=$(cat "${repo_json_file}" | jq '.repo_config .note_base_path_collection | length')
    for((note_counter=0; note_counter < $total_note_base_path; ++note_counter)) do
        each_note_base_path=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_counter}] .note_base_path")
        note_base_path_choose+="${note_counter} ${each_note_base_path}\n"
    done
    note_base_path_choose=${note_base_path_choose%??}
    note_path_text=$(echo -e "${note_base_path_choose}" | gum choose --header="Select Note Base Path")
    note_path_array=(${note_path_text})
    note_path_id_input=${note_path_array[0]}
    dasel put -f "${repo_json_file}" -r json -t int -v ${next_repo_id} 'restic_git_repo.[].id'
    dasel put -f "${repo_json_file}" -r json -t string -v "${pwd_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).pwd"
    dasel put -f "${repo_json_file}" -r json -t string -v "${git_url_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).git_url"
    dasel put -f "${repo_json_file}" -r json -t string -v "${rclone_name_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).rclone_name"
    dasel put -f "${repo_json_file}" -r json -t string -v "${composer_download_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).composer_download"
    dasel put -f "${repo_json_file}" -r json -t string -v "${npm_download_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).npm_download"
    dasel put -f "${repo_json_file}" -r json -t string -v "${database_name_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).database_name"
    dasel put -f "${repo_json_file}" -r json -t string -v "${restic_address_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).restic_address"
    dasel put -f "${repo_json_file}" -r json -t string -v "${restic_password_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).restic_password"
    dasel put -f "${repo_json_file}" -r json -t string -v "${restic_type_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).restic_type"
    dasel put -f "${repo_json_file}" -r json -t string -v "${workstation_type_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).workstation_type"
    dasel put -f "${repo_json_file}" -r json -t string -v "${workstation_name_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).workstation_name"
    dasel put -f "${repo_json_file}" -r json -t string -v "${sync_type_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).sync_type"
    dasel put -f "${repo_json_file}" -r json -t string -v "${note_path_id_input}" "restic_git_repo.all().filter(equal(id,${next_repo_id})).note_path_id"
    echo -e "\033[1;32m Repository Added Successfully. \033[0m"
}

function repo_edit_config() {
    store_repo_config
    filtered_repo_string=$(echo -e "${all_repo_string}" | gum filter --indicator=">" --header="Select Repository To Edit: ID | PWD")
    filtered_repo_array=(${filtered_repo_string})
    repo_id_edit=${filtered_repo_array[0]}
    repo_json=$(cat "${repo_json_file}" | jq ".restic_git_repo[] | select(.id == ${repo_id_edit})")
    pwd_edit=$(echo "${repo_json}" | jq -r '.pwd')
    git_url_edit=$(echo "${repo_json}" | jq -r '.git_url')
    rclone_name_edit=$(echo "${repo_json}" | jq -r '.rclone_name')
    composer_download_edit=$(echo "${repo_json}" | jq -r '.composer_download')
    npm_download_edit=$(echo "${repo_json}" | jq -r '.npm_download')
    database_name_edit=$(echo "${repo_json}" | jq -r '.database_name')
    restic_address_edit=$(echo "${repo_json}" | jq -r '.restic_address')
    restic_password_edit=$(echo "${repo_json}" | jq -r '.restic_password')
    restic_type_edit=$(echo "${repo_json}" | jq -r '.restic_type')
    workstation_type_edit=$(echo "${repo_json}" | jq -r '.workstation_type')
    workstation_name_edit=$(echo "${repo_json}" | jq -r '.workstation_name')
    sync_type_edit=$(echo "${repo_json}" | jq -r '.sync_type')
    note_path_id_get=$(echo "${repo_json}" | jq -r '.note_path_id')
    note_base_path_get=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_path_id_get}].note_base_path")
    note_path_edit="${note_path_id_get} ${note_base_path_get}"

    echo "Edit Repository ->"
    pwd_input=$(gum input --header="Enter Present Working Directory" --placeholder="Write Present Working Directory" --value="${pwd_edit}")
    if [[ ${all_repo_list["${pwd_input}"]} != '' && "${pwd_input}" != "${pwd_edit}" ]]
    then
        echo -e "\033[1;31m Present Working Directory (PWD) Already Exists! \033[0m"
        exit
    fi
    sync_type_input=$(gum choose --header="Select Sync Type" --selected="${sync_type_edit}" "restic-git" "git-only" "restic-only")
    
    if [[ ${sync_type_input} == "restic-only" ]]
    then
        git_url_input="N/A"
    else
        git_url_input=$(gum input --header="Enter Git URL (eg: N/A, URL)" --placeholder="Write Git URL" --value="${git_url_edit}")
    fi

    if [[ ${sync_type_input} == "git-only" ]]    
    then
        composer_download_input=$(gum choose --header="Select Composer Download" --selected="${composer_download_edit}" "yes" "no")
        npm_download_input=$(gum choose --header="Select NPM (Node Package Manger) Download" --selected="${npm_download_edit}" "yes" "no")
        database_name_input=$(gum input --header="Enter Database Name (eg: N/A, VALUE)" --placeholder="Write Database Name" --value="${database_name_edit}")
        restic_type_input="N/A"
        rclone_name_input="N/A"
        restic_address_input="N/A"
        restic_password_input="N/A"
    else
        composer_download_input="N/A"
        npm_download_input="N/A"
        database_name_input="N/A"
        restic_type_input=$(gum choose --header="Enter Restic Type" --selected="${restic_type_edit}" "rclone" "local")
        if [[ ${restic_type_input} == "rclone" ]]
        then
            rclone_name_input=$(rclone listremotes | gum choose --header="Select Rclone Name" --selected="${rclone_name_edit}")
        else
            rclone_name_input="N/A"
        fi
        restic_address_input=$(gum input --header="Enter Restic Address (eg: N/A, VALUE)" --placeholder="Write Restic Address" --value="${restic_address_edit}")
        restic_password_input=$(gum input --header="Enter Restic Password" --placeholder="Write Restic Password" --value="${restic_password_edit}")
    fi

    workstation_type_input=$(gum choose --header="Select Workstation Type" --selected="${workstation_type_edit}" "desktop-pc" "server-pc")
    workstation_name_input=$(gum input --header="Enter Workstation Name (eg: desktop, server)" --placeholder="Write Workstation Name" --value="${workstation_name_edit}")
    note_base_path_choose=""
    total_note_base_path=$(cat "${repo_json_file}" | jq '.repo_config .note_base_path_collection | length')
    for((note_counter=0; note_counter < $total_note_base_path; ++note_counter)) do
        each_note_base_path=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_counter}] .note_base_path")
        note_base_path_choose+="${note_counter} ${each_note_base_path}\n"
    done
    note_base_path_choose=${note_base_path_choose%??}
    note_path_text=$(echo -e "${note_base_path_choose}" | gum choose --header="Select Note Base Path" --selected="${note_path_edit}")
    note_path_array=(${note_path_text})
    note_path_id_input=${note_path_array[0]}
    dasel put -f "${repo_json_file}" -r json -t string -v "${pwd_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).pwd"
    dasel put -f "${repo_json_file}" -r json -t string -v "${git_url_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).git_url"
    dasel put -f "${repo_json_file}" -r json -t string -v "${rclone_name_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).rclone_name"
    dasel put -f "${repo_json_file}" -r json -t string -v "${composer_download_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).composer_download"
    dasel put -f "${repo_json_file}" -r json -t string -v "${npm_download_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).npm_download"
    dasel put -f "${repo_json_file}" -r json -t string -v "${database_name_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).database_name"
    dasel put -f "${repo_json_file}" -r json -t string -v "${restic_address_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).restic_address"
    dasel put -f "${repo_json_file}" -r json -t string -v "${restic_password_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).restic_password"
    dasel put -f "${repo_json_file}" -r json -t string -v "${restic_type_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).restic_type"
    dasel put -f "${repo_json_file}" -r json -t string -v "${workstation_type_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).workstation_type"
    dasel put -f "${repo_json_file}" -r json -t string -v "${workstation_name_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).workstation_name"
    dasel put -f "${repo_json_file}" -r json -t string -v "${sync_type_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).sync_type"
    dasel put -f "${repo_json_file}" -r json -t string -v "${note_path_id_input}" "restic_git_repo.all().filter(equal(id,${repo_id_edit})).note_path_id"
    echo -e "\033[1;32m Repository Updated Successfully. \033[0m"
}

function repo_delete_config() {
    store_repo_config
    filtered_repo_string=$(echo -e "${all_repo_string}" | gum filter --indicator=">" --header="Select Repository To Delete")
    filtered_repo_array=(${filtered_repo_string})
    repo_id_delete=${filtered_repo_array[0]}
    repo_json=$(cat "${repo_json_file}" | jq ".restic_git_repo[] | select(.id == ${repo_id_delete})")
    pwd_delete=$(echo "${repo_json}" | jq -r '.pwd')
    git_url_delete=$(echo "${repo_json}" | jq -r '.git_url')
    rclone_name_delete=$(echo "${repo_json}" | jq -r '.rclone_name')
    composer_download_delete=$(echo "${repo_json}" | jq -r '.composer_download')
    npm_download_delete=$(echo "${repo_json}" | jq -r '.npm_download')
    database_name_delete=$(echo "${repo_json}" | jq -r '.database_name')
    restic_address_delete=$(echo "${repo_json}" | jq -r '.restic_address')
    restic_password_delete=$(echo "${repo_json}" | jq -r '.restic_password')
    restic_type_delete=$(echo "${repo_json}" | jq -r '.restic_type')
    workstation_type_delete=$(echo "${repo_json}" | jq -r '.workstation_type')
    workstation_name_delete=$(echo "${repo_json}" | jq -r '.workstation_name')
    sync_type_delete=$(echo "${repo_json}" | jq -r '.sync_type')
    note_path_id_get=$(echo "${repo_json}" | jq -r '.note_path_id')
    note_base_path_delete=$(cat "${repo_json_file}" | jq ".repo_config .note_base_path_collection[${note_path_id_get}].note_base_path")
    echo "Delete Repository ->"
    repo_show="KEY\tVALUE\n"
    repo_show+="ID\t${repo_id_delete}\n"
    repo_show+="PWD\t${pwd_delete}\n"
    repo_show+="Git URL\t${git_url_delete}\n"
    repo_show+="Rclone Name\t${rclone_name_delete}\n"
    repo_show+="Composer Download\t${composer_download_delete}\n"
    repo_show+="NPM Download\t${npm_download_delete}\n"
    repo_show+="Database Name\t${database_name_delete}\n"
    repo_show+="Restic Address\t${restic_address_delete}\n"
    repo_show+="Restic Password\t${restic_password_delete}\n"
    repo_show+="Restic Type\t${restic_type_delete}\n"
    repo_show+="Workstation Type\t${workstation_type_delete}\n"
    repo_show+="Workstation Name\t${workstation_name_delete}\n"
    repo_show+="Sync Type\t${sync_type_delete}\n"
    repo_show+="Note Base Path\t${note_base_path_delete}"
    printf "${repo_show}" | prettytable 2
    confirm_delete=$(gum confirm --default="No" "Delete This Repository?" && echo "yes" || echo "no")
    if [[ ${confirm_delete} == "yes" ]]
    then
        dasel delete -f "${repo_json_file}" -r json "restic_git_repo.all().filter(equal(id,${repo_id_delete}))"
        echo -e "\033[1;32m Repository Deleted Successfully. \033[0m"
    fi
}

function store_download_config() {
    all_download_string=""
    total_download_count=$(cat "${repo_json_file}" | jq '.download | length')
    for((counter=0; counter < ${total_download_count}; ++counter)) do
        each_download=$(cat "${repo_json_file}" | jq ".download[${counter}]")
        id_json=$(echo "${each_download}" | jq -r '.id')
        type_json=$(echo "${each_download}" | jq -r '.type')
        name_json=$(echo "${each_download}" | jq -r '.name')
        url_json=$(echo "${each_download}" | jq -r '.url')
        all_download_string+="${id_json}\t${type_json}\t${name_json}\n"
    done
    all_download_string=${all_download_string%??}
}

function download_view_config() {
    store_download_config
    filtered_download_string=$(echo -e ${all_download_string} | gum filter --indicator=">" --header="Select Download To View: ID | Type | Name")
    filtered_download_array=(${filtered_download_string})
    filtered_download_id=${filtered_download_array[0]}
    filtered_download_json=$(cat "${repo_json_file}" | jq ".download[] | select(.id == ${filtered_download_id})")
    download_id=$(echo ${filtered_download_json} | jq -r '.id')
    type_get=$(echo ${filtered_download_json} | jq -r '.type')
    name_get=$(echo ${filtered_download_json} | jq -r '.name')
    url_get=$(echo ${filtered_download_json} | jq -r '.url')
    echo "Download Details ->"
    download_show="  KEY|[}|VALUE\n"
    download_show+="  ID|[}|${download_id}\n"
    download_show+="  Type|[}|${type_get}\n"
    download_show+="  Name|[}|${name_get}"
    printf "${download_show}" | column --table --separator "|[}|"
    echo "  URL" "       " $(echo ${url_get} | jq -R)
}

function download_add_config() {
    total_download_count=$(cat "${repo_json_file}" | jq '.download | length')
    if [[ ${total_download_count} == 0 ]]
    then
        next_download_id=1
    else
        last_download_id=$(dasel -f "${repo_json_file}" -r json 'download.last().id')
        next_download_id=$((last_download_id+1))
    fi
    echo "Add Download ->"
    type_input=$(gum choose --header="Select Download Type" "software" "file")
    name_input=$(gum input --header="Enter Download Name" --placeholder="Write Download Name")
    url_input=$(gum write --header="Enter Download URL" --placeholder="Write Download URL")

    for((counter=0; counter < ${total_download_count}; ++counter)) do
        url_check=$(cat "${repo_json_file}" | jq -r ".download[${counter}] .url")
        if [[ "${url_input}" == "${url_check}" ]]
        then
            echo -e "\033[1;31m Download URL Already Exists! \033[0m"
            exit
        fi
    done

    dasel put -f "${repo_json_file}" -r json -t int -v ${next_download_id} 'download.[].id'
    dasel put -f "${repo_json_file}" -r json -t string -v "${type_input}" "download.all().filter(equal(id,${next_download_id})).type"
    dasel put -f "${repo_json_file}" -r json -t string -v "${name_input}" "download.all().filter(equal(id,${next_download_id})).name"
    dasel put -f "${repo_json_file}" -r json -t string -v "${url_input}" "download.all().filter(equal(id,${next_download_id})).url"
    echo -e "\033[1;32m Download Added Successfully. \033[0m"
}

function download_edit_config() {
    store_download_config
    filtered_download_string=$(echo -e ${all_download_string} | gum filter --indicator=">" --header="Select Download To Edit: ID | Type | Name")
    filtered_download_array=(${filtered_download_string})
    filtered_download_id=${filtered_download_array[0]}
    filtered_download_json=$(cat "${repo_json_file}" | jq ".download[] | select(.id == ${filtered_download_id})")
    download_id_edit=$(echo ${filtered_download_json} | jq -r '.id')
    type_edit=$(echo ${filtered_download_json} | jq -r '.type')
    name_edit=$(echo ${filtered_download_json} | jq -r '.name')
    url_edit=$(echo ${filtered_download_json} | jq -r '.url')
    echo "Edit Download ->"
    type_input=$(gum choose --header="Select Download Type" --selected="${type_edit}" "software" "file")
    name_input=$(gum input --header="Enter Download Name" --placeholder="Write Download Name" --value="${name_edit}")
    url_input=$(gum write --header="Enter Download URL" --placeholder="Write Download URL" --value="${url_edit}")

    total_download_count=$(cat "${repo_json_file}" | jq '.download | length')
    for((counter=0; counter < ${total_download_count}; ++counter)) do
        url_check=$(cat "${repo_json_file}" | jq -r ".download[${counter}] .url")
        if [[ "${url_input}" == "${url_check}" && "${url_input}" != "${url_edit}" ]]
        then
            echo -e "\033[1;31m Download URL Already Exists! \033[0m"
            exit
        fi
    done

    dasel put -f "${repo_json_file}" -r json -t string -v "${type_input}" "download.all().filter(equal(id,${download_id_edit})).type"
    dasel put -f "${repo_json_file}" -r json -t string -v "${name_input}" "download.all().filter(equal(id,${download_id_edit})).name"
    dasel put -f "${repo_json_file}" -r json -t string -v "${url_input}" "download.all().filter(equal(id,${download_id_edit})).url"
    echo -e "\033[1;32m Download Updated Successfully. \033[0m"
}

function download_delete_config() {
    store_download_config
    filtered_download_string=$(echo -e ${all_download_string} | gum filter --indicator=">" --header="Select Download To Delete: ID | Type | Name")
    filtered_download_array=(${filtered_download_string})
    filtered_download_id=${filtered_download_array[0]}
    filtered_download_json=$(cat "${repo_json_file}" | jq ".download[] | select(.id == ${filtered_download_id})")
    download_id_delete=$(echo ${filtered_download_json} | jq -r '.id')
    type_delete=$(echo ${filtered_download_json} | jq -r '.type')
    name_delete=$(echo ${filtered_download_json} | jq -r '.name')
    url_delete=$(echo ${filtered_download_json} | jq -r '.url')
    echo "Delete Download ->"
    show_download="
    KEY|[}|VALUE\n
    ID|[}|${download_id_delete}\n
    Type|[}|${type_delete}\n
    Name|[}|${name_delete}\n
    "
    printf "${show_download}" | column --table --separator "|[}|"
    echo "    URL" "       " $(echo ${url_delete} | jq -R)
    confirm_delete=$(gum confirm --default="No" "Delete This Download Data?" && echo "yes" || echo "no")
    if [[ ${confirm_delete} == "yes" ]]
    then
        dasel delete -f "${repo_json_file}" -r json "download.all().filter(equal(id,${download_id_delete}))"
        echo -e "\033[1;32m Download Deleted Successfully. \033[0m"
    fi
}

function import_file_select_config() {
    cd "${repo_file_path}/config-import"
    file_list_string=""
    file_list_array=( * ) # Shell glob-pattern
    for ((i = 0; i < ${#file_list_array[@]}; i++))
    do
        file_list_string+="${file_list_array[$i]}\n"
    done
    file_list_string=${file_list_string%??}
    filtered_file_name=$(echo -e "${file_list_string}" | gum filter --indicator=">" --header="Select Config JSON File To Import Data")
    if [[ ${filtered_file_name} == '*' ]]
    then
        echo "No Config JSON File Selected To Import Data!"
        exit
    else
        import_config_json_file="${repo_file_path}/config-import/${filtered_file_name}"
    fi
}

function import_note_path_config() {
    import_file_select_config
    note_path_choose_import=""
    total_note_path_import=$(cat "${import_config_json_file}" | jq '.repo_config .note_base_path_collection | length')
    for((import_counter=0; import_counter < ${total_note_path_import}; ++import_counter)) do
        each_note_path_import=$(cat "${import_config_json_file}" | jq -r ".repo_config .note_base_path_collection[${import_counter}] .note_base_path")
        note_path_choose_import+="${import_counter}\t${each_note_path_import}\n"
    done
    note_path_choose_import=${note_path_choose_import%??}
    note_path_text_import=$(echo -e "${note_path_choose_import}" | gum filter --indicator=">" --header="Select Note Base Path To Import")
    note_path_array_import=(${note_path_text_import})
    note_path_id_import=${note_path_array_import[0]}
    note_path_value_import=$(cat "${import_config_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_path_id_import}] .note_base_path")
    total_note_path_present=$(cat "${repo_json_file}" | jq '.repo_config .note_base_path_collection | length')
    for((present_counter=0; present_counter < ${total_note_path_present}; ++present_counter)) do
        each_note_path_present=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${present_counter}] .note_base_path")
        if [[ "${note_path_value_import}" == "${each_note_path_present}" ]]
        then
            echo -e "\033[1;31m Note Base Path Already Exists! \033[0m"
            exit
        fi
    done
    confirm_import=$(gum confirm --default="No" "Import Note Base Path: ${note_path_value_import}?" && echo "yes" || echo "no")
    if [[ ${confirm_import} == "yes" ]]
    then
        dasel put -f "${repo_json_file}" -r json -t string -v "${note_path_value_import}" 'repo_config.note_base_path_collection.[].note_base_path'
        echo -e "\033[1;32m Note Base Path Imported Successfully. \033[0m"
    fi
}

function import_repo_config() {
    import_file_select_config
    all_repo_string_import=""
    total_repo_count_import=$(cat "${import_config_json_file}" | jq '.restic_git_repo | length')
    for((import_counter=0; import_counter < ${total_repo_count_import}; ++import_counter)) do
        each_repo_import=$(cat "${import_config_json_file}" | jq ".restic_git_repo[${import_counter}]")
        id_json_import=$(echo "${each_repo_import}" | jq -r '.id')
        pwd_json_import=$(echo "${each_repo_import}" | jq -r '.pwd')
        all_repo_string_import+="${id_json_import}\t${pwd_json_import}\n"
    done
    all_repo_string_import=${all_repo_string_import%??}
    filtered_repo_string_import=$(echo -e "${all_repo_string_import}" | gum filter --indicator=">" --header="Select Repository To Import: ID | PWD")
    filtered_repo_array_import=(${filtered_repo_string_import})
    repo_id_import=${filtered_repo_array_import[0]}
    repo_json_import=$(cat "${import_config_json_file}" | jq -r ".restic_git_repo[] | select(.id == ${repo_id_import})")
    pwd_import=$(echo "${repo_json_import}" | jq -r '.pwd')
    git_url_import=$(echo "${repo_json_import}" | jq -r '.git_url')
    rclone_name_import=$(echo "${repo_json_import}" | jq -r '.rclone_name')
    composer_download_import=$(echo "${repo_json_import}" | jq -r '.composer_download')
    npm_download_import=$(echo "${repo_json_import}" | jq -r '.npm_download')
    database_name_import=$(echo "${repo_json_import}" | jq -r '.database_name')
    restic_address_import=$(echo "${repo_json_import}" | jq -r '.restic_address')
    restic_password_import=$(echo "${repo_json_import}" | jq -r '.restic_password')
    restic_type_import=$(echo "${repo_json_import}" | jq -r '.restic_type')
    workstation_type_import=$(echo "${repo_json_import}" | jq -r '.workstation_type')
    workstation_name_import=$(echo "${repo_json_import}" | jq -r '.workstation_name')
    sync_type_import=$(echo "${repo_json_import}" | jq -r '.sync_type')
    note_path_id_import=$(echo "${repo_json_import}" | jq -r '.note_path_id')
    note_path_value_import=$(cat "${import_config_json_file}" | jq -r ".repo_config .note_base_path_collection[${note_path_id_import}] .note_base_path")
    echo "Import Repository ->"
    repo_show_import="KEY\tVALUE\n"
    repo_show_import+="ID\t${repo_id_import}\n"
    repo_show_import+="PWD\t${pwd_import}\n"
    repo_show_import+="Git URL\t${git_url_import}\n"
    repo_show_import+="Rclone Name\t${rclone_name_import}\n"
    repo_show_import+="Composer Download\t${composer_download_import}\n"
    repo_show_import+="NPM Download\t${npm_download_import}\n"
    repo_show_import+="Database Name\t${database_name_import}\n"
    repo_show_import+="Restic Address\t${restic_address_import}\n"
    repo_show_import+="Restic Password\t${restic_password_import}\n"
    repo_show_import+="Restic Type\t${restic_type_import}\n"
    repo_show_import+="Workstation Type\t${workstation_type_import}\n"
    repo_show_import+="Workstation Name\t${workstation_name_import}\n"
    repo_show_import+="Sync Type\t${sync_type_import}\n"
    repo_show_import+="Note Base Path\t${note_path_value_import}"
    printf "${repo_show_import}" | prettytable 2

    confirm_import=$(gum confirm --default="No" "Import This Repository?" && echo "yes" || echo "no")
    if [[ ${confirm_import} == "yes" ]]
    then
        note_path_id_present=""
        total_note_path_present=$(cat "${repo_json_file}" | jq '.repo_config .note_base_path_collection | length')
        for((present_counter=0; present_counter < ${total_note_path_present}; ++present_counter)) do
            each_note_path_present=$(cat "${repo_json_file}" | jq -r ".repo_config .note_base_path_collection[${present_counter}] .note_base_path")
            if [[ "${note_path_value_import}" == "${each_note_path_present}" ]]
            then
                note_path_id_present=${present_counter}
            fi
        done

        if [[ ${note_path_id_present} == "" ]]
        then
            dasel put -f "${repo_json_file}" -r json -t string -v "${note_path_value_import}" 'repo_config.note_base_path_collection.[].note_base_path'
            note_path_id_present=${total_note_path_present}
            echo "Imported Note Base Path: ${note_path_value_import}"
        fi

        total_repo_count_present=$(cat "${repo_json_file}" | jq '.restic_git_repo | length')
        if [[ ${total_repo_count_present} == 0 ]]
        then
            next_repo_id_present=1
        else
            last_repo_id_present=$(dasel -f "${repo_json_file}" -r json 'restic_git_repo.last().id')
            next_repo_id_present=$((last_repo_id_present+1))
            if [[ ${all_repo_list["${pwd_import}"]} != '' ]]
            then
                echo -e "\033[1;31m Present Working Directory (PWD) Already Exists! \033[0m"
                exit
            fi
        fi

        dasel put -f "${repo_json_file}" -r json -t int -v ${next_repo_id_present} 'restic_git_repo.[].id'
        dasel put -f "${repo_json_file}" -r json -t string -v "${pwd_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).pwd"
        dasel put -f "${repo_json_file}" -r json -t string -v "${git_url_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).git_url"
        dasel put -f "${repo_json_file}" -r json -t string -v "${rclone_name_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).rclone_name"
        dasel put -f "${repo_json_file}" -r json -t string -v "${composer_download_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).composer_download"
        dasel put -f "${repo_json_file}" -r json -t string -v "${npm_download_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).npm_download"
        dasel put -f "${repo_json_file}" -r json -t string -v "${database_name_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).database_name"
        dasel put -f "${repo_json_file}" -r json -t string -v "${restic_address_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).restic_address"
        dasel put -f "${repo_json_file}" -r json -t string -v "${restic_password_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).restic_password"
        dasel put -f "${repo_json_file}" -r json -t string -v "${restic_type_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).restic_type"
        dasel put -f "${repo_json_file}" -r json -t string -v "${workstation_type_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).workstation_type"
        dasel put -f "${repo_json_file}" -r json -t string -v "${workstation_name_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).workstation_name"
        dasel put -f "${repo_json_file}" -r json -t string -v "${sync_type_import}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).sync_type"
        dasel put -f "${repo_json_file}" -r json -t string -v "${note_path_id_present}" "restic_git_repo.all().filter(equal(id,${next_repo_id_present})).note_path_id"
        echo -e "\033[1;32m Repository Imported Successfully. \033[0m"
    fi
}

function import_download_config() {
    import_file_select_config
    all_download_string_import=""
    total_download_import=$(cat "${import_config_json_file}" | jq '.download | length')
    for((import_counter=0; import_counter < ${total_download_import}; ++import_counter)) do
        each_download_import=$(cat "${import_config_json_file}" | jq -r ".download[${import_counter}]")
        id_json_import=$(echo "${each_download_import}" | jq -r '.id')
        type_json_import=$(echo "${each_download_import}" | jq -r '.type')
        name_json_import=$(echo "${each_download_import}" | jq -r '.name')
        all_download_string_import+="${id_json_import}\t${type_json_import}\t${name_json_import}\n"
    done
    all_download_string_import=${all_download_string_import%??}
    filtered_download_string_import=$(echo -e "${all_download_string_import}" | gum filter --indicator=">" --header="Select Download To Import: ID | Type | Name")
    filtered_download_array_import=(${filtered_download_string_import})
    download_id_import=${filtered_download_array_import[0]}
    download_json_import=$(cat "${import_config_json_file}" | jq -r ".download[] | select(.id == ${download_id_import})")
    type_import=$(echo "${download_json_import}" | jq -r '.type')
    name_import=$(echo "${download_json_import}" | jq -r '.name')
    url_import=$(echo "${download_json_import}" | jq -r '.url')
    echo "Import Download ->"
    download_show="  KEY|[}|VALUE\n"
    download_show+="  ID|[}|${download_id_import}\n"
    download_show+="  Type|[}|${type_import}\n"
    download_show+="  Name|[}|${name_import}"
    printf "${download_show}" | column --table --separator "|[}|"
    echo "  URL" "       " $(echo ${url_import} | jq -R)

    confirm_import=$(gum confirm --default="No" "Import This Download?" && echo "yes" || echo "no")
    if [[ ${confirm_import} == "yes" ]]
    then
        total_download_present=$(cat "${repo_json_file}" | jq '.download | length')
        if [[ ${total_download_present} == 0 ]]
        then
            next_download_id_present=1
        else
            last_download_id_present=$(dasel -f "${repo_json_file}" -r json 'download.last().id')
            next_download_id_present=$((last_download_id_present+1))
        fi
        for((present_counter=0; present_counter < ${total_download_present}; ++present_counter)) do
            url_check_present=$(cat "${repo_json_file}" | jq -r ".download[${present_counter}] .url")
            if [[ "${url_import}" == "${url_check_present}" ]]
            then
                echo -e "\033[1;31m Download URL Already Exists! \033[0m"
                exit
            fi
        done
        dasel put -f "${repo_json_file}" -r json -t int -v ${next_download_id_present} 'download.[].id'
        dasel put -f "${repo_json_file}" -r json -t string -v "${type_import}" "download.all().filter(equal(id,${next_download_id_present})).type"
        dasel put -f "${repo_json_file}" -r json -t string -v "${name_import}" "download.all().filter(equal(id,${next_download_id_present})).name"
        dasel put -f "${repo_json_file}" -r json -t string -v "${url_import}" "download.all().filter(equal(id,${next_download_id_present})).url"
        echo -e "\033[1;32m Download Imported Successfully. \033[0m"
    fi
}

if [[ "$1" == "config" ]] # Script/Command: "config"
then
    if [[ "$2" == "help" ]]
    then
        help_config
        exit
    fi

    all_repo_string=""
    all_download_string=""
    import_config_json_file=""
    work_type="$2"
    action="$3"
    case ${work_type} in
        "rbase") # "rbase"="Repository Base"
            case ${action} in
                "list")
                    rbase_list_config;;
                "edit")
                    rbase_edit_config;;
                "notep")
                    rbase_note_path_config;;
            esac;;
        "repo")
            case ${action} in
                "view")
                    repo_list_config;;
                "add")
                    repo_add_config;;
                "edit")
                    repo_edit_config;;
                "delete")
                    repo_delete_config;;
            esac;;
        "download")
            case ${action} in
                "view")
                    download_view_config;;
                "add")
                    download_add_config;;
                "edit")
                    download_edit_config;;
                "delete")
                    download_delete_config;;
            esac;;
        "import")
            case ${action} in
                "notep")
                    import_note_path_config;;
                "repo")
                    import_repo_config;;
                "download")
                    import_download_config;;
            esac;;
    esac
    exit
fi

#----------------------------END: Configuration----------------------------

#----------------------------START-SCRIPT: restic-git----------------------------

rsgit_help_text="init||Initialize new restic repository.\n
backup || [tag] Backup restic repository. Tag is optional. Not local-sync repo.\n
backup-dry-run || Dry Run/Do Not Save restic repository. Not local-sync repo.\n
restore || [snapshot-id] Restore restic repo snapshot. Snapshot-ID is mandatory.\n
snapshots || Shows restic snapshot list.\n
forget || [snapshot-id]Forget restic repo snapshot. Snapshot-ID is mandatory.\n
prune || Prune/Permanent Delete forgotten restic snapshot.\n
check || Check restic repo for errors.\n
cache-clear || Clear restic repo cache.\n
exclude-edit || Edit exclude.txt file for current project.\n
git-uncommitted-sync || Git uncommitted files sync between local-pc and cloud."

help_rsgit() {
  printf "Usage:\njjkk rsgit [work-local] [command]\n\
  [work-local]: Works with locally synchronized restic repository.\n\nAvailabe Commands:\n"
  printf "${rsgit_help_text}" | column --table --separator "||"
}

trim_rsgit() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    printf '%s' "$var"
}

function git_uncommitted_sync_push_rsgit() {
  git_repo_url="$1"
  git_remote_rclone_name=$2
  #echo "Git Repo URL: ${git_repo_url}; Git Remote Rclone: ${git_remote_rclone_name}"
  
  git_changed_files=$(git status -s | awk 'match($0,/"[^"]*"/){print substr($0,RSTART+1,RLENGTH-2);next} {print $2}') # https://stackoverflow.com/questions/71114506/treat-2nd-column-with-space-as-one-column
  #echo "${git_changed_files}"
  
  IFS=$'\n' 
  read -rd '' -a git_changed_files_array <<<"$git_changed_files"
  unset IFS
  
  rclone purge "${git_remote_rclone_name}:${git_uncommitted_sync_remote_base}${PWD}/data" --verbose
  rclone mkdir "${git_remote_rclone_name}:${git_uncommitted_sync_remote_base}${PWD}/data" --verbose
  
  for ((git_changed_inc = 0; git_changed_inc < ${#git_changed_files_array[@]}; git_changed_inc++))
  do
    rclone copyto "${PWD}/${git_changed_files_array[$git_changed_inc]}" "${git_remote_rclone_name}:${git_uncommitted_sync_remote_base}${PWD}/data/${git_changed_files_array[$git_changed_inc]}" --progress
    #echo "${git_changed_files_array[$git_changed_inc]}"
  done
}

function git_uncommitted_sync_pull_rsgit() {
  git_repo_url="$1"
  git_remote_rclone_name=$2
  #echo "Git Repo URL: ${git_repo_url}; Git Remote Rclone: ${git_remote_rclone_name}"
  
  #rclone_changed_files=$(rclone ls "${git_remote_rclone_name}:${git_uncommitted_sync_remote_base}${PWD}/data" | awk 'match($0,/"[^"]*"/){print substr($0,RSTART+1,RLENGTH-2);next} {print $2}') # This does not work here, because "rclone ls" command output includes spaces # https://stackoverflow.com/questions/71114506/treat-2nd-column-with-space-as-one-column
  
  rclone_changed_files=$(rclone ls "${git_remote_rclone_name}:${git_uncommitted_sync_remote_base}${PWD}/data" | awk '{sub(/[^ ]+[ ]+/,"")}1') # https://stackoverflow.com/questions/14327442/treat-second-column-with-spaces-as-one-column-with-awk
  #echo "${rclone_changed_files}"
  
  #rclone ls "${git_remote_rclone_name}:${git_uncommitted_sync_remote_base}${PWD}/data"
  #exit
  IFS=$'\n' 
  read -rd '' -a rclone_changed_files_array <<<"$rclone_changed_files"
  unset IFS
  
  for ((rclone_changed_inc = 0; rclone_changed_inc < ${#rclone_changed_files_array[@]}; rclone_changed_inc++))
  do
    # https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
    var="${rclone_changed_files_array[$rclone_changed_inc]}"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   
    #printf '%s' "$var"
    #${rclone_changed_files_array[$rclone_changed_inc]}="${var}"
	#echo "${var}"
  
  
    rclone copyto "${git_remote_rclone_name}:${git_uncommitted_sync_remote_base}${PWD}/data/${var}" "${PWD}/${var}" --progress
    #echo "${rclone_changed_files_array[$rclone_changed_inc]}"
  done
}

function git_uncommitted_sync_status_rsgit() {
  git_repo_url="$1"
  git_remote_rclone_name=$2
  git_status_remote_path="${git_remote_rclone_name}:${git_uncommitted_sync_remote_base}${PWD}/data"
  rclone tree "${git_status_remote_path}"
}

function git_uncommitted_sync_rsgit() {
  git_sync_todo=$1
  
  is_git_repo=$(git rev-parse --is-inside-work-tree) # Shows Warning (But Works): fatal: not a git repository (or any of the parent directories): .git
  if [[ $is_git_repo == 'true' ]]
  then
    get_git_repo=${git_repo_list[$PWD]}
    if [[ $get_git_repo != '' ]]
    then
	  git_repo_details=(${git_repo_list[$PWD]})
	  git_repo_url=${git_repo_details[0]}
	  git_remote_rclone_name=${git_repo_details[1]}
	  
	  # Check "rclone" remote exists or not
	  if [[ $(rclone listremotes | grep "${git_remote_rclone_name}:") != "${git_remote_rclone_name}:" ]]
	  then
	    echo -e "\033[41mRclone: ${git_remote_rclone_name} does not exist! Add it using command -- rclone config\033[m"
	    exit
	  fi
	  
      if [[ ${git_sync_todo} == "push" ]]
	  then
	    git_uncommitted_sync_push_rsgit ${git_repo_url} ${git_remote_rclone_name}
	  elif [[ ${git_sync_todo} == "pull" ]]
	  then
	    git_uncommitted_sync_pull_rsgit ${git_repo_url} ${git_remote_rclone_name}
	  elif [[ ${git_sync_todo} == "status" ]]
	  then
	    git_uncommitted_sync_status_rsgit ${git_repo_url} ${git_remote_rclone_name}
	  else
	    echo "Git: Wrong input! Enter correct input - (push/pull)."
	  fi
  else
    echo 'Git: No entry for current directory in git repository list!'
  fi
  else
    echo -e "\033[41mGit: Current directory is not a git repository!\033[m"
  fi
}

function restic_init_rsgit() {
    restic init
}

function restic_backup_rsgit() {
  is_git_repo=$(git rev-parse --is-inside-work-tree) # Shows Warning (But Works): fatal: not a git repository (or any of the parent directories): .git
  if [[ ${is_git_repo} == 'true' ]]
  then
    git_commit_id=$(git rev-parse HEAD)
    if [[ ${commit_snap_tag_id} == '' ]]
    then
      restic backup . --exclude-file="${exclude_file_path}" --tag "git-commit:${git_commit_id}" --verbose
    else
      restic backup . --exclude-file="${exclude_file_path}" --tag "git-commit:${git_commit_id}" --tag "${commit_snap_tag_id}" --verbose
    fi 
  else
	if [[ ${commit_snap_tag_id} == '' ]]
    then
      restic backup . --exclude-file="${exclude_file_path}" --verbose
    else
      restic backup . --exclude-file="${exclude_file_path}" --tag "${commit_snap_tag_id}" --verbose
    fi
  fi
}

function restic_backup_dry_run_rsgit() {
    restic backup --dry-run . --exclude-file="${exclude_file_path}"
}

function restic_restore_rsgit() {
  if [[ ${commit_snap_tag_id} != '' ]]
  then
    read -p "Enter Path of Backup Restoration (For Current Directory Leave Empty): `echo $'\n> '`" restore_path
	if [[ ${restore_path} == '' ]]
	then
	  restic restore ${commit_snap_tag_id} --target . --verbose
	else
	  restic restore ${commit_snap_tag_id} --target "${restore_path}" --verbose
	fi    
  else
    echo 'Restore (Restic): Please Enter Snapshot ID.'
  fi
}

function restic_snapshots_rsgit() {
  if [[ ${commit_snap_tag_id} == '' ]]
  then
    restic snapshots
  else
    restic snapshots --tag "git-commit:${commit_snap_tag_id}"
  fi
}

function restic_forget_rsgit() {
  if [[ ${commit_snap_tag_id} != '' ]]
  then
    restic forget ${commit_snap_tag_id}
  else
    echo 'Forget (Restic): Please Enter Snapshot ID.'
  fi
}

function restic_prune_rsgit() {
  restic prune
}

function restic_check_rsgit() {
  restic check
}

# Only use if "exclude.txt" file is changed.
function restic_cache_clear_rsgit() {
  restic cache --cleanup --max-age 0
}

function restic_exclude_file_exist_check_rsgit() {
  if [ ! -f "$exclude_file_path" ]
  then
    echo "Exclude File Not Found!"
	if [[ ${operating_system} == 'Linux' ]]
	then
	  sudo mkdir -p "$exclude_file_parent_folder" && touch "${exclude_file_parent_folder}/exclude.txt"
	else # Windows-OS
	  mkdir -p "$exclude_file_parent_folder" && touch "${exclude_file_parent_folder}/exclude.txt" # Windows-OS does not have "sudo" command
	fi
	echo "Created exclude file at ${exclude_file_parent_folder}/exclude.txt"
  fi
}

function restic_exclude_edit_rsgit() {
  restic_exclude_file_exist_check_rsgit

  if [[ ${operating_system} == 'Linux' ]]
  then
    sudo vim "$exclude_file_path"
  else # Windows-OS
    vim "$exclude_file_path" # Windows-OS does not have "sudo" command
  fi
}

#echo 'echo from "restic-git"'
#exit

function get_restic_repo_details_rsgit() {
  working_repo_type="$1"
  get_restic_repo=${restic_repo_list[$PWD]}
  if [[ ${get_restic_repo} != '' ]]
  then
    get_restic_repo_array=(${get_restic_repo})
    restic_repo_path_url=${get_restic_repo_array[0]}
    restic_repo_password=${get_restic_repo_array[1]}
    restic_repo_type=${get_restic_repo_array[2]} # Restic Repository Type: local/rclone(remote)
    restic_repo_remote_name=${get_restic_repo_array[3]}
    workstation_type=${get_restic_repo_array[4]} # Workstation Type: desktop-pc/server-pc
    workstation_name=${get_restic_repo_array[5]}
    sync_type=${get_restic_repo_array[6]} # Synchronization Type: restic-git/git-only/restic-only
    
    if [[ ${workstation_type} == 'desktop-pc' ]]
    then
      exclude_file_parent_folder="${desktop_exclude_base_path}/${workstation_name}${PWD}"   
    else
      exclude_file_parent_folder="${server_exclude_base_path}/${workstation_name}${PWD}"
    fi
  
    exclude_file_path="${exclude_file_parent_folder}/exclude.txt"
    restic_exclude_file_exist_check_rsgit
  
    if [[ ${restic_repo_type} == 'rclone' ]]
    then
      # Check "rclone" remote exists or not
	  if [[ $(rclone listremotes | grep "${restic_repo_remote_name}:") != "${restic_repo_remote_name}:" ]]
	  then
	    echo -e "\033[41mRclone: ${restic_repo_remote_name} does not exist! Add it using command -- rclone config\033[m"
	    exit
	  fi
	  
	  # Use locally synchronized restic repository instead of cloud
	  if [[ ${working_repo_type} == 'local' ]]
	  then
	    sync_repo_local_path="${sync_restic_repo_base_path}/restic-${workstation_name}$PWD"
		if [ ! -f "${sync_repo_local_path}/config" ]
	    then
	      echo -e "\033[41mNo synchronized restic repository for current directory!\033[m"
		  exit
	    fi
		export RESTIC_REPOSITORY=${sync_repo_local_path}
		export RESTIC_PASSWORD=${sync_restic_repo_password}
		return
	  fi
	
	  restic_repo_address="rclone:${restic_repo_remote_name}:restic-${workstation_name}${PWD}"
	  
#----------------------------START: Auto Open/Close Terminal Window----------------------------
      # Description: Open new terminal window to run command "rclone serve restic". An easy alternative is implemented above.  
	  
      #restic_repo_address="rest:http://localhost:8080/restic-${workstation_name}${PWD}/"
      #curl_http_code=$(curl --write-out '%{http_code}' --silent --output /dev/null http://127.0.0.1:8080)
	  #if [[ $curl_http_code == '000' ]] # 200=Successful-Request, 400=Bad-Request(Here this response code is received. It is happened for sending non-valid input. But it works), 404=Not-Found
	  #then
	    #if [[ $workstation_type == 'desktop-pc' ]] # For: desktop-pc
	    #then
	      #if [[ $operating_system == 'Linux' ]] # Desktop-Linux
	      #then
            #${linux_terminal_command} "rclone serve restic --verbose ${restic_repo_remote_name}:" & # Tested For: xterm
            #sleep 3
          #else # Windows-OS
	        #start ${git_bash_path} -c "rclone serve restic --verbose ${restic_repo_remote_name}:"
	      #fi
	    #else # For: server-pc
	      #if [[ $operating_system == 'Linux' ]] # Server-Linux
		  #then
		    #screen -dmS rclone_serve_restic bash -c "rclone serve restic --verbose ${restic_repo_remote_name}:"
		  #fi
	    #fi
	  #fi
#--------------------------END: Auto Open/Close Terminal Window---------------------------------
	  
    else
      restic_repo_address=${restic_repo_path_url}  
    fi
    export RESTIC_REPOSITORY=${restic_repo_address}
    export RESTIC_PASSWORD=${restic_repo_password}
  else
    echo 'Restic: No entry for current directory in restic repository list!'
  fi
}

if [[ "$1" == 'rsgit' ]] # Script/Command: "restic-git"
then
  if [[ "$2" == "help" ]]
  then
    help_rsgit
    exit
  fi
  if [[ $2 == 'work-local' ]]
  then
    working_repo_type='local'
    work_type="$3" # Work Type: init/backup/backup-dry-run/restore/snapshot/forget/prune/check/exclude-edit
    commit_snap_tag_id="$4" # For Backup it is Tag-Name / For Restore it is Snapshot-ID / For Snapshot it is Git-Commit-ID
  else
    working_repo_type='remote'
    work_type="$2"
    commit_snap_tag_id="$3"
  fi

  operating_system=$(uname -s)

  if [[ ${work_type} != "--git-uncommitted-sync" ]]
  then
    get_restic_repo_details_rsgit ${working_repo_type}
  fi

  if [[ ${work_type} == "init" ]]
  then
    restic_init_rsgit
  elif [[ ${work_type} == "backup" ]]
  then
    if [[ ${working_repo_type} == 'remote' ]]
    then
      restic_backup_rsgit
    else
      echo "Sync-Restic-Repo: Backup is not allowed in synchronized restic repository."
    fi
  elif [[ ${work_type} == "backup-dry-run" ]]
  then
    if [[ ${working_repo_type} == 'remote' ]]
    then
    restic_backup_dry_run_rsgit
    else
      echo "Sync-Restic-Repo: Backup-Dry-Run is not allowed in synchronized restic repository."
    fi
  elif [[ ${work_type} == "restore" ]]
  then
    restic_restore_rsgit
  elif [[ ${work_type} == "snapshots" ]]
  then
    restic_snapshots_rsgit
  elif [[ ${work_type} == "forget" ]]
  then
    restic_forget_rsgit
  elif [[ ${work_type} == "prune" ]]
  then
    restic_prune_rsgit
  elif [[ ${work_type} == "check" ]]
  then
    restic_check_rsgit
  elif [[ ${work_type} == "cache-clear" ]]
  then
    restic_cache_clear_rsgit
  elif [[ ${work_type} == "exclude-edit" ]]
  then
    restic_exclude_edit_rsgit
  elif [[ ${work_type} == "git-uncommitted-sync" ]]
  then
    git_uncommitted_sync_pull $3
  fi
  exit
fi
#----------------------------END-SCRIPT: restic-git----------------------------

#----------------------------START-SCRIPT: restic-drive----------------------------

rsdrive_help_text="init || Initialize restic repository in Portable HDD.\n
  backup || [tag] Backup restic repository. Tag is optional.\n
  backup-dry-run || Dry Run/Do Not Save restic repository.\n
  restore || [snapshot-id] Restore restic repository snapshot. Snapshot-ID is mandatory.\n
  snapshots || Shows restic snapshot list.\n
  forget || [snapshot-id] Forget restic specific snapshot. Snapshot-ID is mandatory.\n
  prune || Prune/Permanently Delete forgotten snapshots.\n
  check || Check restic repository for errors.\n
  cache-clear || Clear restic repository cache.\n
  exclude-edit || Edit exclude.txt file for drive."

function help_rsdrive() {
  printf "Usage:\njjkk rsdrive [command]\n\nAvailabe Commands:\n"
  printf "${rsdrive_help_text}" | column --table --separator "||"
}

function restic_init_rsdrive() {
  restic init
}

function restic_backup_rsdrive() {
  if [[ ${commit_snap_tag_id} == '' ]]
  then
    restic backup "${backup_content_path}" --exclude-file="${exclude_file_path}" --verbose
  else
    restic backup "${backup_content_path}" --exclude-file="${exclude_file_path}" --tag "${commit_snap_tag_id}" --verbose
  fi
}

function restic_backup_dry_run_rsdrive() {
  restic backup --dry-run "${backup_content_path}" --exclude-file="${exclude_file_path}"
}

function restic_restore_rsdrive() {
  if [[ ${commit_snap_tag_id} != '' ]]
  then
    read -p "Enter Path of Backup Restoration: `echo $'\n> '`" restore_path
	if [[ ${restore_path} != '' ]]
	then
	  if [ -d "${restore_path}" ]
      then
        restic restore ${commit_snap_tag_id} --target "${restore_path}" --verbose
	  else
	    echo "Restore (Restic): Backup restore path '${restore_path}' does not exist!"
      fi
	else
	  echo "Restore (Restic): Backup restore path can not be empty!"
	fi    
  else
    echo "Restore (Restic): Please Enter Snapshot ID."
  fi
}

function restic_snapshots_rsdrive() {
  restic snapshots
}

function restic_forget_rsdrive() {
  if [[ ${commit_snap_tag_id} != '' ]]
  then
    restic forget ${commit_snap_tag_id}
  else
    echo 'Forget (Restic): Please Enter Snapshot ID.'
  fi
}

function restic_prune_rsdrive() {
  restic prune
}

function restic_check_rsdrive() {
  restic check
}

# Only use if "exclude.txt" file is changed.
function restic_cache_clear_rsdrive() {
  restic cache --cleanup --max-age 0
}

function restic_exclude_file_exist_check_rsdrive() {
  if [ ! -f "$exclude_file_path" ]
  then
    echo "Exclude File Not Found!"
	if [[ ${operating_system} == 'Linux' ]]
	then
	  sudo mkdir -p "${exclude_file_parent_folder}" && touch "${exclude_file_parent_folder}/exclude.txt"
	else # Windows-OS
	  mkdir -p "${exclude_file_parent_folder}" && touch "${exclude_file_parent_folder}/exclude.txt" # Windows-OS does not have "sudo" command
	fi
	echo "Created exclude file at ${exclude_file_parent_folder}/exclude.txt"
  fi  
}

function restic_exclude_edit_rsdrive() {
  restic_exclude_file_exist_check_rsdrive

  if [[ ${operating_system} == 'Linux' ]]
  then
    sudo vim "${exclude_file_path}"
  else # Windows-OS
    vim "${exclude_file_path}" # Windows-OS does not have "sudo" command
  fi
}

if [[ "$1" == "rsdrive" ]] # Script/Command: "restic-drive"
then
  if [[ "$2" == "help" ]]
  then
    help_rsdrive
    exit
  fi

  work_type="$2" # Work Type: init/backup/backup-dry-run/restore/snapshot/forget/prune/check
  commit_snap_tag_id="$3" # For Backup it is Tag-Name / For Restore it is Snapshot-ID

  # Find Portable HDD Drive Letter
  read -p "Which drive do you want to work with (p[project]/d[document])?: `echo $'\n> '`" drive_work_with
  if [[ ${drive_work_with} == 'p' ]]
  then
    psd_identification_file="${project_drive_psd_identification}"
    restic_repo_name="${project_drive_repo_name}"
    backup_content_path="${project_drive_path}"
  elif [[ ${drive_work_with} == 'd' ]]
  then
    psd_identification_file="${document_drive_psd_identification}"
    restic_repo_name="${document_drive_repo_name}"
    backup_content_path="${document_drive_path}"
  else
    echo 'Restic: Wrong Input! Enter (p[project]/d[document]) [Which drive do you want to work with?]'
    exit
  fi

  exclude_file_parent_folder="${desktop_exclude_base_path}/restic-drive${backup_content_path}"
  exclude_file_path="${exclude_file_parent_folder}/exclude.txt"
  restic_exclude_file_exist_check_rsdrive

  psd_drive_letter='NOT-FOUND' # psd = portable-storage-device
  for alphabet in {a..z}
  do
    if [ -f "/${alphabet}/${psd_identification_file}" ]
    then
      psd_drive_letter="${alphabet}"
    fi
  done

  echo "Portable HDD Drive Letter: ${psd_drive_letter}"
  if [[ ${psd_drive_letter} == 'NOT-FOUND' ]]
  then
    exit
  fi

  restic_psd_repo_path="/${psd_drive_letter}/${restic_repo_name}"
  read -p "Current Restic Repository Path is '${restic_psd_repo_path}' (To accept leave empty OR write to change): `echo $'\n> '`" restic_repo_path_confirm
  if [[ "${restic_repo_path_confirm}" != '' ]]
  then
    restic_psd_repo_path="${restic_repo_path_confirm}"
  fi
  echo "Working Restic Repository Path: '${restic_psd_repo_path}'"

  operating_system=$(uname -s)

  export RESTIC_REPOSITORY=${restic_psd_repo_path}
  export RESTIC_PASSWORD=${drive_restic_repo_password}

  if [[ ${work_type} == "init" ]]
  then
    restic_init_rsdrive
  elif [[ ${work_type} == "backup" ]]
  then  
    restic_backup_rsdrive  
  elif [[ ${work_type} == "backup-dry-run" ]]
  then
    restic_backup_dry_run_rsdrive  
  elif [[ ${work_type} == "restore" ]]
  then
    restic_restore_rsdrive
  elif [[ ${work_type} == "snapshots" ]]
  then
    restic_snapshots_rsdrive
  elif [[ ${work_type} == "forget" ]]
  then
    restic_forget_rsdrive
  elif [[ ${work_type} == "prune" ]]
  then
    restic_prune_rsdrive
  elif [[ ${work_type} == "check" ]]
  then
    restic_check_rsdrive
  elif [[ ${work_type} == "cache-clear" ]]
  then
    restic_cache_clear_rsdrive
  elif [[ ${work_type} == "exclude-edit" ]]
  then
    restic_exclude_edit_rsdrive
  fi
  exit
fi
#----------------------------END-SCRIPT: restic-drive----------------------------


#----------------------------START-SCRIPT: sync-restic-repo----------------------------

rssync_help_text="[single-repo-sync] || Synchronize current project's restic repo between local-pc and cloud. This is Default.\n
all-repo-sync || Synchronize all restic repo between local-pc and cloud that are defined in \"json\" file."

function help_rssync() {
  printf "Usage:\njjkk rssync [command]\n\nAvailabe Commands:\n"
  printf "${rssync_help_text}" | column --table --separator "||"
}

function sync_restic_repo_single_rssync() {
  restic_repo_pwd_path="$1"
  restic_repo_path_url="$2"
  restic_repo_from_password="$3"
  restic_repo_type="$4" # Restic Repository Type: local/rclone(remote)
  restic_repo_remote_name="$5"
  restic_workstation_type="$6" # Workstation Type: desktop-pc/server-pc
  restic_workstation_name="$7"
  restic_sync_type="$8" # Synchronization Type: restic-git/git-only/restic-only
  restic_sync_to_path="${sync_restic_repo_base_path}/restic-${restic_workstation_name}${restic_repo_pwd_path}"
  
  if [[ ${restic_repo_type} == 'rclone' ]]
  then
    export RESTIC_REPOSITORY=${restic_sync_to_path}
    export RESTIC_PASSWORD=${sync_restic_repo_password}
	restic_repo_from_address="rclone:${restic_repo_remote_name}:restic-${restic_workstation_name}${restic_repo_pwd_path}"
    #restic_repo_from_address="rest:http://localhost:8080/restic-${restic_workstation_name}${restic_repo_pwd_path}/"
	
	if [ ! -f "${restic_sync_to_path}/config" ]
	then
	  restic init
	fi
	export RESTIC_FROM_REPOSITORY=${restic_repo_from_address}
	export RESTIC_FROM_PASSWORD=${restic_repo_from_password}
	restic copy
	
	unset RESTIC_REPOSITORY
	unset RESTIC_PASSWORD
	unset RESTIC_FROM_REPOSITORY
	unset RESTIC_FROM_PASSWORD
  fi
  
  #echo "${restic_sync_to_path}"
  #echo "Restic PWD Path: ${restic_repo_pwd_path}; Restic Repo Path URL: ${restic_repo_path_url}; Restic Repo Password: ${restic_repo_password}; Restic Repo Type: ${restic_repo_type}; Restic Repo Remote Name: ${restic_repo_remote_name}; Restic Workstation Type: ${restic_workstation_type}; Restic Workstation Name: ${restic_workstation_name}; Restic Sync Type: ${restic_sync_type}"
}

function sync_restic_repo_all_rssync() {
  sync_repo_todo=$1
 
  if [[ ${sync_repo_todo} == 'all_repo_sync' ]]
  then
    read -p "Restic-Remote: Do you want to sync remote-backup for all repository (yes[auto]/no/manual/exit[program]) [Sync Path: ${sync_restic_repo_base_path}]: `echo $'\n> '`" restic_global_confirm
  else
    read -p "Restic-Remote: Do you want to sync remote-backup for single repository (yes[auto]/no) [Sync Path: ${sync_restic_repo_base_path}]: `echo $'\n> '`" restic_single_confirm
	if [[ ${restic_single_confirm} == 'yes' ]]
	then
	  restic_global_confirm='yes' # yes[auto]
	elif [[ ${restic_single_confirm} == 'no' ]]
	then
	  exit
	else
	  echo 'Restic-Remote: Wrong Input! Enter (yes/no) [Do you want to sync remote-backup for single repository?]'
	  exit
	fi
    
  fi
  
  if [[ ${restic_global_confirm} != 'yes' && ${restic_global_confirm} != 'no' && ${restic_global_confirm} != 'manual' && ${restic_global_confirm} != 'exit' ]]
  then
    echo 'Restic-Remote: Wrong Input! Enter (yes[auto]/no/manual/exit[program]) [Do you want to sync remote-backup?]'
	exit
  elif [[ ${restic_global_confirm} == 'no' ]]
  then
    return
  elif [[ ${restic_global_confirm} == 'exit' ]]
  then
    echo 'Restic-Remote: Wrong Input! Enter (yes/no) [Do you want to sync remote-backup?]'
    exit
  fi

  restic_repo_remote_list=() # "rclone" remotes
  declare -A restic_repo_remote_data
  restic_remote_inc=10000001
  
  for restic_repo_key in "${!restic_repo_list[@]}"
  do
    if [[ "${sync_repo_todo}" == 'single_repo_sync' && "${restic_repo_key}" != $PWD ]]
	  then
	    continue
	  fi
  
    restic_repo_details_array=(${restic_repo_list["${restic_repo_key}"]})
	  restic_repo_path_url=${restic_repo_details_array[0]}
    restic_repo_password=${restic_repo_details_array[1]}
    restic_repo_type=${restic_repo_details_array[2]} # Restic Repository Type: local/rclone(remote)
    restic_repo_remote_name=${restic_repo_details_array[3]}
    restic_workstation_type=${restic_repo_details_array[4]} # Workstation Type: desktop-pc/server-pc
    restic_workstation_name=${restic_repo_details_array[5]}
    restic_sync_type=${restic_repo_details_array[6]} # Synchronization Type: restic-git/git-only/restic-only
    operating_system=$(uname -s)
	
	  if [[ ${restic_repo_type} == 'local' ]]
	  then
	    continue
	  fi
	
    if [[ ${restic_workstation_type} == 'desktop-pc' ]]
    then
	    if [[ " ${restic_repo_remote_list[*]} " != *"$restic_repo_remote_name"* ]];
      then
	      restic_repo_remote_list+=("${restic_repo_remote_name}")
        #echo "NO, your arr does not contain $SEARCH_STRING"
      fi
	  
	    restic_repo_remote_data["${restic_repo_remote_name}-${restic_remote_inc}"]="${restic_repo_key}*?${restic_repo_list[${restic_repo_key}]}"
	    ((restic_remote_inc=restic_remote_inc+1))
	  
      #sync_restic_repo_single ${restic_repo_key} ${restic_repo_path_url} ${restic_repo_password} ${restic_repo_type} ${restic_repo_remote_name} ${restic_workstation_type} ${restic_workstation_name} ${restic_sync_type}
    else
      continue
    fi
  done
  
  for restic_cloud_inc in "${!restic_repo_remote_list[@]}"; do 
    printf "%s\t%s\n" "$restic_cloud_inc" "${restic_repo_remote_list[$restic_cloud_inc]}"

    # Check "rclone" remote exists or not
    if [[ $(rclone listremotes | grep "${restic_repo_remote_list[$restic_cloud_inc]}:") != "${restic_repo_remote_list[$restic_cloud_inc]}:" ]]
    then
      echo -e "\033[41mRclone: ${restic_repo_remote_name} does not exist. Add it using command -- rclone config\033[m"
      continue
    fi
	
	  if [[ ${restic_global_confirm} == 'manual' ]] # Select "rclone-remote" manually (Both Windows-OS and Linux-OS)
	  then
	    read -p "Restic-Remote: Do you want to sync remote-backup from \"${restic_repo_remote_list[$restic_cloud_inc]}\" (yes/no[next]/exit[program]) [Sync Path: ${sync_restic_repo_base_path}]: `echo $'\n> '`" restic_sync_confirm
	    if [[ ${restic_sync_confirm} == 'no' ]]
	    then
	      continue
	    elif [[ ${restic_sync_confirm} == 'exit' ]]
	    then
	      exit
	    elif [[ ${restic_sync_confirm} != 'yes' && ${restic_sync_confirm} != 'no' && ${restic_sync_confirm} != 'exit' ]]
	    then
	      echo 'Restic-Remote: Wrong Input! Enter (yes/no/exit[program]) [Do you want to sync remote-backup?]'
	      exit
	    fi
	  fi
	
#----------------------------START: Auto Open/Close Terminal Window----------------------------	
	#if [[ $operating_system == 'Linux' && ${restic_global_confirm} != 'manual' ]] # If-Start: 'rclone-serve-restic' block # Linux-OS
	#then
      #count_rclone_terminal=$(ps ax | grep "${linux_terminal_name}" | grep -v "grep" | wc -l)
      #if [[ ${count_rclone_terminal} == 0 ]]
      #then
        #${linux_terminal_command} "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:" &
        #sleep 3
      #elif [[ ${count_rclone_terminal} == 1 ]]
      #then
        #echo 'Action to stop rclone'
	    #sleep 3
        #rclone_terminal_pid=$(ps ax | grep "${linux_terminal_name}" | grep -v "grep" | awk '{print $1}')
        #kill -SIGINT ${rclone_terminal_pid}
	    #sleep 6
        #${linux_terminal_command} "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:" &
        #sleep 3
      #else
        #echo "Not Zero/One ${linux_terminal_name} running. Start/Close additional ${linux_terminal_name}"
      #fi

	  #echo "'rclone-serve-restic' for Linux-OS"   
	#elif [[ ${restic_global_confirm} == 'manual' ]] # 'rclone-serve-restic' Manual Mode (Both Windows-OS and Linux-OS)
    #then
	  #read -p "Restic-Remote: Do you want to sync remote-backup from \"${restic_repo_remote_list[$restic_cloud_inc]}\" (yes/no[next]/exit[program]) [Close any running Rclone-Serve-Restic window] [Sync Path: ${sync_restic_repo_base_path}]: `echo $'\n> '`" restic_sync_confirm
		
      #if [[ $restic_sync_confirm == 'yes' ]] # If-Start: 'restic_sync_confirm'
	  #then
	    #curl_http_code=$(curl --write-out '%{http_code}' --silent --output /dev/null http://127.0.0.1:8080)
	    #if [[ $curl_http_code == '000' ]] # If-Start: 'curl_http_code' # 200=Successful-Request, 400=Bad-Request(Here this response code is received. It is happened for sending non-valid input. But it works), 404=Not-Found
	    #then
	      #if [[ $restic_workstation_type == 'desktop-pc' ]] # If-Start: 'workstation_type' # For: desktop-pc
		  #then
		    #if [[ $operating_system == 'Linux' ]] #If-Start: 'operating_system' # Desktop-Linux
		    #then
		      #${linux_terminal_command} "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:" &
		    #else # Windows-OS
		      #start ${git_bash_path} -c "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:"
		    #fi #If-End: 'operating_system'
		  #fi # If-End: 'workstation_type'
		  #sleep 3 # Wait 3 seconds to work, after "rclone" starts
	    #fi # If-End: 'curl_http_code'
	  #elif [[ $restic_sync_confirm == 'no' ]]
	  #then
	    #continue
	  #elif [[ $restic_sync_confirm == 'exit' ]]
	  #then
	    #exit
	  #elif [[ ${restic_sync_confirm} != 'yes' && ${restic_sync_confirm} != 'no' && ${restic_sync_confirm} != 'exit' ]]
      #then
        #echo 'Restic-Remote: Wrong Input! Enter (yes/no/exit[program]) [Do you want to sync remote-backup?]'
	    #exit
	  #fi # If-End: 'restic_sync_confirm'  
	#else # 'rclone-serve-restic' for Windows-OS
	  #count_mintty_running=$(ps | grep '/usr/bin/mintty' | wc -l)
      #if [[ ${count_mintty_running} == 1 ]]
      #then
        #restic_git_mintty_pid=$(ps | grep '/usr/bin/mintty' | awk '{print $1}')
        #start ${git_bash_path} -c "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:"
		#sleep 3
	  #elif [[ ${count_mintty_running} == 2 ]]
	  #then
        #echo 'Action to stop rclone'
		#sleep 3
	    #rclone_mintty_pid=$(ps | grep '/usr/bin/mintty' | awk '{print $1}' | grep -v "${restic_git_mintty_pid}")
		#kill -SIGINT ${rclone_mintty_pid}
		#sleep 6
		
		#start ${git_bash_path} -c "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:"
		#sleep 3
		
		# ps | grep '/usr/bin/mintty' | awk '{print $1}' | grep -v "${restic_git_mintty_pid}"
		#echo "Restic Mintty: ${restic_git_mintty_pid}"
		#echo "Rclone Mintty: ${rclone_mintty_pid}"
		#exit
      #else
        #echo 'Not One/Two Mintty running. Start/Close additional Mintty'
      #fi	  
	#fi # If-End: 'rclone-serve-restic' block
#--------------------------END: Auto Open/Close Terminal Window--------------------------------	
	
	  for restic_remote_key in "${!restic_repo_remote_data[@]}"; do
	    restic_remote_key_trim=${restic_remote_key%?????????} # Trim last 9 character
	    if [[ "${restic_remote_key_trim}" == "${restic_repo_remote_list[$restic_cloud_inc]}" ]] 
	    then
	      # Prints Repository Details: Project Path (PWD), restic-repository-address(local/remote(N/A)) restic-repository-password repository-type(local/rclone) remote-repository-name(rclone/N/A) workstation-type(desktop-pc/server-pc) workstation-name synchronization-type(restic-git/git-only/restic-only)
		
	      #echo ${restic_repo_remote_data[${restic_remote_key}]}
		    #restic_remote_data_array=(${restic_repo_remote_data[${restic_remote_key}]})
		
		    IFS='*?' read -r -a restic_remote_data_split <<< "${restic_repo_remote_data[${restic_remote_key}]}"
		    unset IFS
		
		    current_working_directory="${restic_remote_data_split[0]}"
		    restic_remote_data_array=(${restic_remote_data_split[2]})
		
		    sync_restic_repo_single_rssync "${current_working_directory}" "${restic_remote_data_array[0]}" "${restic_remote_data_array[1]}" "${restic_remote_data_array[2]}" "${restic_remote_data_array[3]}" "${restic_remote_data_array[4]}" "${restic_remote_data_array[5]}" "${restic_remote_data_array[6]}"
	    fi
	  done
  done
}

if [[ "$1" == "rssync" ]] # Script/Command: "sync-restic-repo"
then
  if [[ "$2" == "help" ]]
  then
    help_rssync
    exit
  fi

  if [[ "$2" == 'all-repo-sync' ]]
  then
    sync_repo_todo='all_repo_sync'
  else
    sync_repo_todo='single_repo_sync'
  fi

  sync_restic_repo_all_rssync ${sync_repo_todo}
  exit
fi
#----------------------------END-SCRIPT: sync-restic-repo----------------------------


#----------------------------START-SCRIPT: restore-restic-git----------------------------
function help_rsrestore() {
  printf "Usage:\njjkk rsrestore
  There are no additional commands.\n"
}

function git_clone_single_rsrestore() {
  git_project_pwd_path="$1"
  git_project_path="${git_project_pwd_path:3}"
  git_repo_url="$2"
  git_repo_remote_name="$3"
  composer_do_download="$4" # PHP Composer
  npm_do_download="$5" # Node Package Manager (NPM)
  git_clone_to_path="${restore_restic_git_base_path}/${git_project_path}"
  
  if [ ! -d "${git_clone_to_path}" ]
  then
    git clone "${git_repo_url}" "${git_clone_to_path}"
  else
    echo "Git: Directory ${git_clone_to_path} already exists. Skipping..."
  fi
  
  #echo "Git Project Path: ${git_project_path}; Git Repo URL: ${git_repo_url}; Composer Download: ${composer_do_download}; NPM Download: ${npm_do_download}; Git Clone To Path: ${git_clone_to_path}"
}

function restic_restore_single_repo_rsrestore() {
  restic_repo_pwd_path="$1"
  restic_restore_to_path="${restic_repo_pwd_path:3}"
  restic_repo_path_url="$2"
  restic_repo_password="$3"
  restic_repo_type="$4" # Restic Repository Type: local/rclone(remote)
  restic_repo_remote_name="$5"
  restic_workstation_type="$6" # Workstation Type: desktop-pc/server-pc
  restic_workstation_name="$7"
  restic_sync_type="$8" # Synchronization Type: restic-git/git-only/restic-only
  
  if [[ ${restic_repo_type} == 'rclone' ]]
  then
  restic_repo_address="rclone:${restic_repo_remote_name}:restic-${restic_workstation_name}${restic_repo_pwd_path}"
  #restic_repo_address="rest:http://localhost:8080/restic-${restic_workstation_name}${restic_repo_pwd_path}/"
  else
    restic_repo_address=${restic_repo_path_url}
  fi
  
  export RESTIC_REPOSITORY=${restic_repo_address}
  export RESTIC_PASSWORD=${restic_repo_password}
  
  restic_restore_target_path="${restore_restic_git_base_path}/${restic_restore_to_path}"
  restic restore latest --target "${restic_restore_target_path}"
  
  #echo ${restore_restic_git_base_path}/${restic_restore_to_path}
  #echo "Restic PWD Path: ${restic_repo_pwd_path}; Restic Repo Path URL: ${restic_repo_path_url}; Restic Repo Password: ${restic_repo_password}; Restic Repo Type: ${restic_repo_type}; Restic Repo Remote Name: ${restic_repo_remote_name}; Restic Workstation Type: ${restic_workstation_type}; Restic Workstation Name: ${restic_workstation_name}; Restic Sync Type: ${restic_sync_type}"
}

function git_clone_all_rsrestore() {
  read -p "Git: Do you want to clone all git repository (yes/no/exit[program])? [Clone Path: ${restore_restic_git_base_path}]: `echo $'\n> '`" git_global_confirm
  if [[ ${git_global_confirm} != 'yes' && ${git_global_confirm} != 'no' && ${git_global_confirm} != 'exit' ]]
  then
    echo 'Git: Wrong Input! Enter (yes/no/exit[program]) [Do you want to clone all git repository?]'
	exit
  elif [[ ${git_global_confirm} == 'no' ]]
  then
    return
  elif [[ ${git_global_confirm} == 'exit' ]]
  then
    exit
  fi
  
  for git_repo_key in "${!git_repo_list[@]}"
  do
    git_repo_details_array=(${git_repo_list["${git_repo_key}"]})
    git_clone_single "${git_repo_key}" "${git_repo_details_array[0]}" "${git_repo_details_array[1]}" "${git_repo_details_array[2]}" "${git_repo_details_array[3]}"
  done
}

function restic_restore_remote_all_rsrestore() {
  read -p "Restic-Remote: Do you want to restore backup (yes[auto]/no/manual/exit[program]) [Restore Path: ${restore_restic_git_base_path}]: `echo $'\n> '`" restic_global_confirm
  
  if [[ ${restic_global_confirm} != 'yes' && ${restic_global_confirm} != 'no' && ${restic_global_confirm} != 'manual' && ${restic_global_confirm} != 'exit' ]]
  then
    echo 'Restic-Remote: Wrong Input! Enter (yes[auto]/no/manual/exit[program]) [Do you want to restore backup?]'
	exit
  elif [[ ${restic_global_confirm} == 'no' ]]
  then
    return
  elif [[ ${restic_global_confirm} == 'exit' ]]
  then
    exit
  fi

  restic_repo_remote_list=() # "rclone" remotes
  declare -A restic_repo_remote_data
  restic_remote_inc=10000001
  
  for restic_repo_key in "${!restic_repo_list[@]}"
  do
    restic_repo_details_array=(${restic_repo_list["${restic_repo_key}"]})
	  restic_repo_path_url=${restic_repo_details_array[0]}
    restic_repo_password=${restic_repo_details_array[1]}
    restic_repo_type=${restic_repo_details_array[2]} # Restic Repository Type: local/rclone(remote)
    restic_repo_remote_name=${restic_repo_details_array[3]}
    restic_workstation_type=${restic_repo_details_array[4]} # Workstation Type: desktop-pc/server-pc
    restic_workstation_name=${restic_repo_details_array[5]}
    restic_sync_type=${restic_repo_details_array[6]} # Synchronization Type: restic-git/git-only/restic-only
    operating_system=$(uname -s)
	
	  if [[ ${restic_repo_type} == 'local' ]]
	  then
	    continue
	  fi
	
    if [[ ${restic_workstation_type} == 'desktop-pc' && ${restic_sync_type} == 'restic-git' ]]
    then
	    if [[ " ${restic_repo_remote_list[*]} " != *"$restic_repo_remote_name"* ]];
      then
	      restic_repo_remote_list+=("${restic_repo_remote_name}")
        #echo "NO, your arr does not contain $SEARCH_STRING"
      fi
	  
	    restic_repo_remote_data["${restic_repo_remote_name}-${restic_remote_inc}"]="${restic_repo_key}*?${restic_repo_list[${restic_repo_key}]}"
	    ((restic_remote_inc=restic_remote_inc+1))
	
      #restic_restore_single_repo ${restic_repo_key} ${restic_repo_path_url} ${restic_repo_password} ${restic_repo_type} ${restic_repo_remote_name} ${restic_workstation_type} ${restic_workstation_name} ${restic_sync_type}
    else
      continue
    fi
  done
  
  for restic_cloud_inc in "${!restic_repo_remote_list[@]}"; do 
    printf "%s\t%s\n" "$restic_cloud_inc" "${restic_repo_remote_list[$restic_cloud_inc]}"

    # Check "rclone" remote exists or not
    if [[ $(rclone listremotes | grep "${restic_repo_remote_list[$restic_cloud_inc]}:") != "${restic_repo_remote_list[$restic_cloud_inc]}:" ]]
    then
      echo -e "\033[41mRclone: ${restic_repo_remote_name} does not exist. Add it using command -- rclone config\033[m"
      continue
    fi
	
	  if [[ ${restic_global_confirm} == 'manual' ]] # Select "rclone-remote" manually (Both Windows-OS and Linux-OS)
	  then
	    read -p "Restic-Remote: Do you want to restore backup from \"${restic_repo_remote_list[$restic_cloud_inc]}\" (yes/no[next]/exit[program]) [Restore Path: ${restore_restic_git_base_path}]: `echo $'\n> '`" restic_restore_confirm
	    if [[ ${restic_restore_confirm} == 'no' ]]
	    then
	      continue
	    elif [[ ${restic_restore_confirm} == 'exit' ]]
	    then
	      exit
	    elif [[ ${restic_restore_confirm} != 'yes' && ${restic_restore_confirm} != 'no' && ${restic_restore_confirm} != 'exit' ]]
	    then
	      echo 'Restic-Remote: Wrong Input! Enter (yes/no/exit[program]) [Do you want to restore backup?]'
		    exit
	    fi
	  fi
	
#----------------------------START: Auto Open/Close Terminal Window----------------------------	
    # Description: Open new terminal window to run command "rclone serve restic". An easy alternative is implemented above.

	#if [[ $operating_system == 'Linux' && ${restic_global_confirm} != 'manual' ]] # If-Start: 'rclone-serve-restic' block # Linux-OS
	#then
      #count_rclone_terminal=$(ps ax | grep "${linux_terminal_name}" | grep -v "grep" | wc -l)
      #if [[ ${count_rclone_terminal} == 0 ]]
      #then
        #${linux_terminal_command} "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:" &
        #sleep 3
      #elif [[ ${count_rclone_terminal} == 1 ]]
      #then
        #echo 'Action to stop rclone'
	    #sleep 3
        #rclone_terminal_pid=$(ps ax | grep "${linux_terminal_name}" | grep -v "grep" | awk '{print $1}')
        #kill -SIGINT ${rclone_terminal_pid}
	    #sleep 6
        #${linux_terminal_command} "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:" &
        #sleep 3
      #else
        #echo "Not Zero/One ${linux_terminal_name} running. Start/Close additional ${linux_terminal_name}"
      #fi

	  #echo "'rclone-serve-restic' for Linux-OS"   
	#elif [[ ${restic_global_confirm} == 'manual' ]] # 'rclone-serve-restic' Manual Mode (Both Windows-OS and Linux-OS)
    #then
	  #read -p "Restic-Remote: Do you want to restore backup from \"${restic_repo_remote_list[$restic_cloud_inc]}\" (yes/no[next]/exit[program]) [Close any running Rclone-Serve-Restic window] [Restore Path: ${restore_restic_git_base_path}]: `echo $'\n> '`" restic_restore_confirm
		
      #if [[ $restic_restore_confirm == 'yes' ]] # If-Start: 'restic_restore_confirm'
	  #then
	    #curl_http_code=$(curl --write-out '%{http_code}' --silent --output /dev/null http://127.0.0.1:8080)
	    #if [[ $curl_http_code == '000' ]] # If-Start: 'curl_http_code' # 200=Successful-Request, 400=Bad-Request(Here this response code is received. It is happened for sending non-valid input. But it works), 404=Not-Found
	    #then
	      #if [[ $restic_workstation_type == 'desktop-pc' ]] # If-Start: 'workstation_type' # For: desktop-pc
		  #then
		    #if [[ $operating_system == 'Linux' ]] #If-Start: 'operating_system' # Desktop-Linux
		    #then
		      #${linux_terminal_command} "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:" &
		    #else # Windows-OS
		      #start ${git_bash_path} -c "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:"
		    #fi #If-End: 'operating_system'
		  #fi # If-End: 'workstation_type'
		  #sleep 3 # Wait 3 seconds to work, after "rclone" starts
	    #fi # If-End: 'curl_http_code'
	  #elif [[ $restic_restore_confirm == 'no' ]]
	  #then
	    #continue
	  #elif [[ $restic_restore_confirm == 'exit' ]]
	  #then
	    #exit
	  #elif [[ ${restic_restore_confirm} != 'yes' && ${restic_restore_confirm} != 'no' && ${restic_restore_confirm} != 'exit' ]]
      #then
        #echo 'Restic-Remote: Wrong Input! Enter (yes/no/exit[program]) [Do you want to restore backup?]'
	    #exit
	  #fi # If-End: 'restic_restore_confirm'  
	#else # 'rclone-serve-restic' for Windows-OS
	  #count_mintty_running=$(ps | grep '/usr/bin/mintty' | wc -l)
      #if [[ ${count_mintty_running} == 1 ]]
      #then
        #restic_git_mintty_pid=$(ps | grep '/usr/bin/mintty' | awk '{print $1}')
        #start ${git_bash_path} -c "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:"
		#sleep 3
	  #elif [[ ${count_mintty_running} == 2 ]]
	  #then
        #echo 'Action to stop rclone'
		#sleep 3
	    #rclone_mintty_pid=$(ps | grep '/usr/bin/mintty' | awk '{print $1}' | grep -v "${restic_git_mintty_pid}")
		#kill -SIGINT ${rclone_mintty_pid}
		#sleep 6
		
		#start ${git_bash_path} -c "rclone serve restic --verbose ${restic_repo_remote_list[$restic_cloud_inc]}:"
		#sleep 3
		
		# ps | grep '/usr/bin/mintty' | awk '{print $1}' | grep -v "${restic_git_mintty_pid}"
		#echo "Restic Mintty: ${restic_git_mintty_pid}"
		#echo "Rclone Mintty: ${rclone_mintty_pid}"
		#exit
      #else
        #echo 'Not One/Two Mintty running. Start/Close additional Mintty'
      #fi	  
	#fi # If-End: 'rclone-serve-restic' block
#--------------------------END: Auto Open/Close Terminal Window--------------------------------	
	
	for restic_remote_key in "${!restic_repo_remote_data[@]}"; do
	  restic_remote_key_trim=${restic_remote_key%?????????} # Trim last 9 character
	  if [[ "${restic_remote_key_trim}" == "${restic_repo_remote_list[$restic_cloud_inc]}" ]] 
	  then
	    # Prints Repository Details: Project Path (PWD), restic-repository-address(local/remote(N/A)) restic-repository-password repository-type(local/rclone) remote-repository-name(rclone/N/A) workstation-type(desktop-pc/server-pc) workstation-name synchronization-type(restic-git/git-only/restic-only)
		
	    #echo ${restic_repo_remote_data[${restic_remote_key}]}
		  #restic_remote_data_array=(${restic_repo_remote_data[${restic_remote_key}]})

      IFS='*?' read -r -a restic_remote_data_split <<< "${restic_repo_remote_data[${restic_remote_key}]}"
		  unset IFS

      current_working_directory="${restic_remote_data_split[0]}"
		  restic_remote_data_array=(${restic_remote_data_split[2]})
		
		  restic_restore_single_repo "${current_working_directory}" "${restic_remote_data_array[0]}" "${restic_remote_data_array[1]}" "${restic_remote_data_array[2]}" "${restic_remote_data_array[3]}" "${restic_remote_data_array[4]}" "${restic_remote_data_array[5]}" "${restic_remote_data_array[6]}"
	    fi
	  done
  done
}

function restic_restore_local_all_rsrestore() {
  read -p "Restic-Local: Do you want to restore backup from local repository (yes/no/exit[program]) [Restore Path: ${restore_restic_git_base_path}]: `echo $'\n> '`" restic_restore_confirm
  
  if [[ ${restic_restore_confirm} != 'yes' && ${restic_restore_confirm} != 'no' && ${restic_restore_confirm} != 'exit' ]]
  then
    echo 'Restic-Local: Wrong Input! Enter (yes/no/exit[program]) [Do you want to restore backup from local repository?]'
	  exit
  elif [[ ${restic_restore_confirm} == 'no' ]]
  then
    return
  elif [[ ${restic_restore_confirm} == 'exit' ]]
  then
    exit
  fi
  
  for restic_repo_key in "${!restic_repo_list[@]}"
  do
    restic_repo_details_array=(${restic_repo_list[$restic_repo_key]})
	  restic_repo_path_url=${restic_repo_details_array[0]}
    restic_repo_password=${restic_repo_details_array[1]}
    restic_repo_type=${restic_repo_details_array[2]} # Restic Repository Type: local/rclone(remote)
    restic_repo_remote_name=${restic_repo_details_array[3]}
    restic_workstation_type=${restic_repo_details_array[4]} # Workstation Type: desktop-pc/server-pc
    restic_workstation_name=${restic_repo_details_array[5]}
    restic_sync_type=${restic_repo_details_array[6]} # Synchronization Type: restic-git/git-only/restic-only
    operating_system=$(uname -s)
	
	  if [[ ${restic_repo_type} == 'rclone' ]]
	  then
	    continue
	  fi
	
	  if [[ ${restic_workstation_type} == 'desktop-pc' && ${restic_sync_type} == 'restic-git' ]]
	  then
	    restic_restore_single_repo ${restic_repo_key} ${restic_repo_path_url} ${restic_repo_password} ${restic_repo_type} ${restic_repo_remote_name} ${restic_workstation_type} ${restic_workstation_name} ${restic_sync_type}
	  fi
  done
}

if [[ "$1" == "rsrestore" ]] # Script/Command: "restore-restic-git"
then
  if [[ "$2" == "help" ]]
  then
    help_rsrestore
    exit
  fi

  git_clone_all_rsrestore
  restic_restore_remote_all_rsrestore
  restic_restore_local_all_rsrestore
  exit
fi
#----------------------------END-SCRIPT: restore-restic-git----------------------------


#----------------------------START-SCRIPT: gist----------------------------

ghgist_help_text="--create || Create GitHub Gist.\n
 || List gist using file description, [description][#tag-1][#tag-2][#tag-3]. Select a gist to edit or delete.\n"

function help_ghgist() {
  printf "Usage:\njjkk gist [command]\n\nAvailabe Commands:\n"
  printf "${ghgist_help_text}" | column --table --separator "||"
}

function gist_create_ghgist() {
  gist_create_command="gh gist create"
  read -p "Enter new gist title(description) (Enter 'exit' to close program): `echo $'\n> '`" entered_gist_description
  if [[ "${entered_gist_description}" == '' ]]
  then
    echo "Gist title(description) can not be empty!"
	exit
  elif [[ "${entered_gist_description}" == 'exit' ]]
  then
    exit
  else
    for ((i=1; i<=${max_gist_create}; i++))
	  do
	    read -p "${i}) Choose gist create action (y[es]/n[o]/exit): `echo $'\n> '`" choose_create_action
	    if [[ "${choose_create_action}" == 'y' ]]
	    then
	      read -p "${i}) Enter new file name: `echo $'\n> '`" entered_file_name
		    if [[ "${entered_file_name}" == '' ]]
	      then
	        echo "Gist-Create: File name can not be empty!"
		      continue
		    fi
		    eval touch "'${gist_temporary_folder}/${entered_file_name}'"
		    eval ${editor_open_command}"'${gist_temporary_folder}/${entered_file_name}'"
		    gist_create_command+=" '${gist_temporary_folder}/${entered_file_name}'"
		    continue
	    elif [[ "${choose_create_action}" == 'exit' ]]
	    then
	      exit
	    elif [[ "${choose_create_action}" == 'n' ]]
	    then
	      echo "Gist-Create: Creating Gist..."
		  break
	    else
	      echo "Wrong input! Enter file name to create ('y[es]/n[o]/exit')"
	    fi
	  done
  fi
  
  gist_create_command+=" --desc '${entered_gist_description}'"
  eval "${gist_create_command}"
  
  #echo "'${gist_create_command}'"
  #echo "echo from gist-create"
}

function gist_view_ghgist() {
  selected_gist_id="$1"
  gist_file_list=$(gh gist view "${selected_gist_id}" --files)
  
  IFS=$'\n' read -d '' -r -a gist_file_array <<<"$gist_file_list"
  unset IFS 
  for ((i = 0; i < ${#gist_file_array[@]}; i++))
  do
    echo "$i) ${gist_file_array[$i]}"
  done
  
  read -p "Enter file number you want to view (Enter 'exit' to close program): `echo $'\n> '`" entered_file_number
  if [[ ${entered_file_number} == 'exit' ]]
  then
    exit
  fi
  selected_file_view="${gist_file_array[$entered_file_number]}"
  if [[ ${selected_file_view} == '' ]]
  then
    echo "Wrong file number is entered!"
	exit
  fi
  gh gist view "${selected_gist_id}" --filename "${selected_file_view}">"${gist_temporary_file}"
  ${editor_open_command}"${gist_temporary_file}"
  #echo "echo from gist-view"
}

function gist_edit_ghgist() {
  selected_gist_id="$1"
  read -p "Enter gist edit type (a[dd-file]/e[dit-file]/t[itle-description]): `echo $'\n> '`" entered_edit_type
  if [[ "${entered_edit_type}" == 'a' ]] # a[dd-file]
  then
    read -p "Enter new file name: `echo $'\n> '`" entered_new_file_name
	  if [[ "${entered_new_file_name}" == '' ]]
	  then
	    echo "New file name can not be empty!"
	  else
	    gist_edit_new_file="${gist_temporary_folder}/${entered_new_file_name}"
	    if [ ! -f "${gist_edit_new_file}" ]
	    then
	      touch "${gist_edit_new_file}"
	    fi
	    echo ''>"${gist_edit_new_file}"
	    eval ${editor_open_command}"'${gist_edit_new_file}'"
	    read -p "New file is opened in editor, write there. Do you want to save changes (y[es]/exit)? `echo $'\n> '`" confirm_save_changes
	    if [[ "${confirm_save_changes}" == 'y' ]] # y[es]
	    then
	      eval ${is_winpty}gh gist edit "${selected_gist_id}" --add "'${gist_edit_new_file}'"
		    #rm "${gist_edit_new_file}"
		    echo "Gist-Edit: File added successfully."
	    else
	      exit
	    fi
	  fi
  elif [[ "${entered_edit_type}" == 'e' ]] # e[dit-file]
  then
    ${is_winpty}gh gist edit "${selected_gist_id}"
#-----------------------------START: Edit using file number-----------------------------  
    #gist_file_list=$(gh gist view "${selected_gist_id}" --files)
  
    #IFS=$'\n' read -d '' -r -a gist_file_array <<<"$gist_file_list"
    #unset IFS 
    #for ((i = 0; i < ${#gist_file_array[@]}; i++))
    #do
      #echo "$i) ${gist_file_array[$i]}"
    #done
  
    #read -p "Enter file number you want to view (Enter 'exit' to close program): `echo $'\n> '`" entered_file_number
    #if [[ ${entered_file_number} == 'exit' ]]
    #then
      #exit
    #fi
    #selected_file_edit="${gist_file_array[$entered_file_number]}"
    #if [[ ${selected_file_edit} == '' ]]
    #then
      #echo "Wrong file number is entered!"
	  #exit
    #fi
	#${is_winpty}gh gist edit "${selected_gist_id}" --filename "${selected_file_edit}"
#-----------------------------END: Edit using file number-----------------------------
	  echo "Gist-Edit: File edited successfully."
  elif [[ "${entered_edit_type}" == 't' ]] # t[itle-description]
  then
    read -p "Enter new gist description (with '#tag'): `echo $'\n> '`" entered_new_description
    if [[ "${entered_new_description}" == '' ]]
    then
      echo "Gist description can not be empty!"
    else
	    eval ${is_winpty}gh gist edit "${selected_gist_id}" --desc "'${entered_new_description}'"
	    echo "Gist-Edit: Title(Description) edited successfully."
    fi
  else
    echo "Wrong input! Enter gist edit type (add[file]/edit[file]/description)"
  fi
  
  #echo "echo from gist-edit"
}

function gist_delete_ghgist() {
  selected_gist_id="$1"
  selected_gist_description="$2"
  read -p "Do you want to delete gist '${selected_gist_description}' (yes-delete-this-gist-entirely/no)? `echo $'\n> '`" confirm_gist_delete
  if [[ "${confirm_gist_delete}" == 'yes-delete-this-gist-entirely' ]]
  then
    gh gist delete "${selected_gist_id}"
  else
    echo "You have rejected to delete gist." 
  fi
  echo "Deleted Gist: ${selected_gist_description}"
  #echo "echo from gist-delete"
}

function gist_list_ghgist() {
  echo "echo from gist-list"
}

if [[ "$1" == "gist" ]] # Script/Command: "gist"
then
  if [[ "$2" == "help" ]]
  then
    help_ghgist
    exit
  fi

  operating_system=$(uname -s)
  if [[ ${operating_system} == 'Linux' ]]
  then
    is_winpty=""
    editor_open_command="${linux_editor} "
  else
    is_winpty="winpty " # Git-Bash(mintty.exe) does not support "user-prompt", use "winpty"
    editor_open_command="start ${windows_editor} "
  fi
  if [ ! -d "${gist_temporary_folder}" ]
  then
    mkdir -p "${gist_temporary_folder}"
    touch "${gist_temporary_file}"
  fi
  eval rm "${gist_temporary_folder}/*"
  if [ ! -f "${gist_temporary_file}" ]
  then
    touch "${gist_temporary_file}"
  fi

  if [[ "$2" == "--create" ]]
  then
    gist_create_ghgist
  else
    description_text="$2" # "gist-description", leave "" (empty) to search only using tag
    tag_one="$3" # Enter tag name like "#tag-one" "#tag-two" "#tag-three"
    tag_two="$4"
    tag_three="$5"  
    get_gist_list=$(gh gist list --limit ${gist_list_limit} | grep -i "${tag_one}" | grep -i "${tag_two}" | grep -i "${tag_three}" | grep -i "${description_text}")
  
    IFS=$'\n' read -d '' -r -a gist_list_array <<<"$get_gist_list"
    unset IFS 
    for ((i = 0; i < ${#gist_list_array[@]}; i++))
    do
      echo "$i) ${gist_list_array[$i]}"
    done
  
    read -p "Enter gist number you want to work with (Enter 'exit' to close program): `echo $'\n> '`" entered_gist_number
    if [[ ${entered_gist_number} == 'exit' ]]
    then
      exit
    fi
    choose_gist_record=${gist_list_array[$entered_gist_number]}
    if [[ ${choose_gist_record} == '' ]]
    then
      echo "Wrong gist number is entered!"
	    exit
    fi
  
    IFS=" " #It is separator of string. Press keyboard "Tab" character inside double quotation
    set ${choose_gist_record}   #Set string for IFS
    selected_gist_id="$1"
    selected_gist_description="$2"
    selected_gist_file_count="$3"
    selected_gist_type="$4"  # Gist type: secret/public
    echo ${choose_gist_record}
    unset IFS

    read -p "What to do with selected gist (v[iew]/e[dit]/d[elete]/b[rowser-open]/exit)? `echo $'\n> '`" work_type
    if [[ ${work_type} == 'v' ]] # v[iew]
    then
      gist_view_ghgist "${selected_gist_id}"
    elif [[ ${work_type} == 'e' ]] # e[dit]
    then
      gist_edit_ghgist "${selected_gist_id}"
    elif [[ ${work_type} == 'd' ]] # d[elete]
    then
      gist_delete_ghgist "${selected_gist_id}" "${selected_gist_description}"
    elif [[ ${work_type} == 'b' ]] # b[rowser-open]
    then
      gh gist view "${selected_gist_id}" --web
    elif [[ ${work_type} == 'exit' ]]
    then
      exit
    else
      echo "Invalid option selected! Enter option - view/edit/delete/exit"
    fi
  
    #echo "Gist-ID: ${selected_gist_id}; Gist-Description: ${selected_gist_description}; Gist-File-Count: ${selected_gist_file_count}; Gist-Type: ${selected_gist_type}"
  fi
  exit
fi
#----------------------------END-SCRIPT: gist----------------------------


#----------------------------START-SCRIPT: pjnote----------------------------

pjnote_help_text="create || Create new note.\n
open || Open existing note.\n
rename || Rename existing note.\n
delete || Delete existing note.\n
about || Open about.md file. If does not exist, then create.\n
todo || Open todo.md file. If does not exist, then create.\n
bug || Open bug.md file. If does not exist, then create.\n
guide || Open guide.md file. If does not exist, then create.\n
document || Open document.md file. If does not exist, then create.\n
password || Open password.md file. If does not exist, then create.\n
status || Shows changed files using 'git status'.\n
commit || Git commit changed files using 'git commit'.\n
push || Push git commits using 'git push'.\n
fetch || Fetch git commits from remote git repo using 'git fetch'.\n
pull || Fetch and Merge git commits from remote git repo using 'git pull'.\n
mkdocs-serve || MKDocs serve project markdown files."

function help_pjnote() {
  printf "Usage:\njjkk note [command]\n\nAvailabe Commands:\n"
  printf "${pjnote_help_text}" | column --table --separator "||"
}

function create_pjnote() {
  read -p "Enter name for new file with file-extension: `echo $'\n> '`" entered_file_name
  if [[ "${entered_file_name}" == '' ]]
  then
    echo "File name can not be empty!"
  else
    touch "${note_parent_folder}/${entered_file_name}"
	echo "Created file: '${note_parent_folder}/${entered_file_name}'"
  fi
}

function open_pjnote() {
  cd "${note_parent_folder}"
  
  file_list_array=( * ) # Shell glob-pattern
  for ((i = 0; i < ${#file_list_array[@]}; i++))
  do
    echo "$i) ${file_list_array[$i]}"
  done
  
  selected_file_number='invalid'
  read -p "Enter file number you want to open (Enter 'exit' to close program): `echo $'\n> '`" entered_file_number
  for ((i = 0; i < ${#file_list_array[@]}; i++))
  do
    if [[ "${entered_file_number}" == 'exit' ]]
	then
	  exit
	fi
  
  if [[ "${entered_file_number}" == "$i" ]]
	then
	  selected_file_number="${entered_file_number}"
	fi
    #echo "$i) ${file_list_array[$i]}"
  done
  
  if [[ "${selected_file_number}" == 'invalid' ]]
  then
    echo "You entered wrong file number!"
  else
    echo "Opened file: '${note_parent_folder}/${file_list_array[$selected_file_number]}'"
    ${editor_open_command}"${note_parent_folder}/${file_list_array[$selected_file_number]}"
  fi
  
  #echo "File Number Selected: ${selected_file_number}"
}

function rename_pjnote() {
  cd "${note_parent_folder}"
  
  file_list_array=( * )
  for ((i = 0; i < ${#file_list_array[@]}; i++))
  do
    echo "$i) ${file_list_array[$i]}"
  done
  
  selected_file_number='invalid'
  read -p "Enter file number you want to rename (Enter 'exit' to close program): `echo $'\n> '`" entered_file_number
  for ((i = 0; i < ${#file_list_array[@]}; i++))
  do
    if [[ "${entered_file_number}" == 'exit' ]]
	  then
	    exit
	  fi
  
    if [[ "${entered_file_number}" == "$i" ]]
	  then
	    selected_file_number="${entered_file_number}"
	  fi
    #echo "$i) ${file_list_array[$i]}"
  done
  
  if [[ "${selected_file_number}" == 'invalid' ]]
  then
    echo "You entered wrong file number!"
  else
    read -p "Enter new name for file '${file_list_array[$selected_file_number]}' with file-extension: `echo $'\n> '`" entered_new_file_name
	  if [[ "${entered_new_file_name}" == '' ]]
	  then
	    echo "File name can not be empty!"
	  else
	    mv "${note_parent_folder}/${file_list_array[$selected_file_number]}" "${note_parent_folder}/${entered_new_file_name}"
	    echo "Renamed file to: '${note_parent_folder}/${entered_new_file_name}'"
	  fi 
  fi
  
  #echo "File Number Selected: ${selected_file_number}"
}

function delete_pjnote() {
  cd "${note_parent_folder}"
  
  file_list_array=( * )
  for ((i = 0; i < ${#file_list_array[@]}; i++))
  do
    echo "$i) ${file_list_array[$i]}"
  done
  
  selected_file_number='invalid'
  read -p "Enter file number you want to delete (Enter 'exit' to close program): `echo $'\n> '`" entered_file_number
  for ((i = 0; i < ${#file_list_array[@]}; i++))
  do
    if [[ "${entered_file_number}" == 'exit' ]]
	  then
	    exit
	  fi
  
    if [[ "${entered_file_number}" == "$i" ]]
	  then
	    selected_file_number="${entered_file_number}"
	  fi
    #echo "$i) ${file_list_array[$i]}"
  done
  
  if [[ "${selected_file_number}" == 'invalid' ]]
  then
    echo "You entered wrong file number!"
  else
    read -p "Do you want to delete file '${file_list_array[$selected_file_number]}' (yes/no)? `echo $'\n> '`" delete_confirmation
	  if [[ "${delete_confirmation}" == 'yes' ]]
	  then
	    rm "${note_parent_folder}/${file_list_array[$selected_file_number]}"
	    echo "Deleted file: '${note_parent_folder}/${file_list_array[$selected_file_number]}'"
	  else
	    echo "You have rejected to delete file."
	  fi
  fi
  
  #echo "File Number Selected: ${selected_file_number}"
}

function about_file_pjnote() {
  about_file_path="${note_parent_folder}/about.md"
  if [ ! -f "${about_file_path}" ]
  then
    touch "${about_file_path}"
	  echo "Created about file: '${about_file_path}'"
  fi
  
  echo "Opened file: '${about_file_path}'"
  ${editor_open_command}"${about_file_path}"
  #echo 'echo from note-about'
}

function todo_file_pjnote() {
  todo_file_path="${note_parent_folder}/todo.md"
  if [ ! -f "${todo_file_path}" ]
  then
    touch "${todo_file_path}"
	  echo "Created todo file: '${todo_file_path}'"
  fi
  
  echo "Opened file: '${todo_file_path}'"
  ${editor_open_command}"${todo_file_path}"
  #echo 'echo from note-todo'
}

function bug_file_pjnote() {
  bug_file_path="${note_parent_folder}/bug.md"
  if [ ! -f "${bug_file_path}" ]
  then
    touch "${bug_file_path}"
	  echo "Created bug file: '${bug_file_path}'"
  fi
  
  echo "Opened file: '${bug_file_path}'"
  ${editor_open_command}"${bug_file_path}"
  #echo 'echo from note-bug'
}

function guide_file_pjnote() {
  guide_file_path="${note_parent_folder}/guide.md"
  if [ ! -f "${guide_file_path}" ]
  then
    touch "${guide_file_path}"
	  echo "Created guide file: '${guide_file_path}'"
  fi
  
  echo "Opened file: '${guide_file_path}'"
  ${editor_open_command}"${guide_file_path}"
  #echo 'echo from note-guide'
}

function document_file_pjnote() {
  document_file_path="${note_parent_folder}/document.md"
  if [ ! -f "${document_file_path}" ]
  then
    touch "${document_file_path}"
	  echo "Created document file: '${document_file_path}'"
  fi
  
  echo "Opened file: '${document_file_path}'"
  ${editor_open_command}"${document_file_path}"
  #echo 'echo from note-document'
}

function password_file_pjnote() {
  password_file_path="${note_parent_folder}/password.md"
  if [ ! -f "${password_file_path}" ]
  then
    touch "${password_file_path}"
	  echo "Created password file: '${password_file_path}'"
  fi
  
  echo "Opened file: '${password_file_path}'"
  ${editor_open_command}"${password_file_path}"
  #echo 'echo from note-password'
}

function git_status_pjnote() {
  cd "${note_base_path}"
  echo "Present-Working-Directory: '${PWD}'"
  is_git_repo=$(git rev-parse --is-inside-work-tree) # Shows Warning (But Works): fatal: not a git repository (or any of the parent directories): .git
  if [[ ${is_git_repo} == 'true' ]]
  then
	  git status
  fi

  #echo 'echo from git-status'
}

function git_commit_pjnote() {
  cd "${note_base_path}"
  echo "Present-Working-Directory: '${PWD}'"
  is_git_repo=$(git rev-parse --is-inside-work-tree) # Shows Warning (But Works): fatal: not a git repository (or any of the parent directories): .git
  if [[ ${is_git_repo} == 'true' ]]
  then
    if [[ "${git_commit_message}" == '' ]]
	  then
	    echo "Git: Commit message is empty. Can not commit!"
	    exit
	  fi
	  git add .
	  git commit -m "${git_commit_message}"
  fi

  #echo 'echo from git-commit'
}

function git_push_pjnote() {
  cd "${note_base_path}"
  echo "Present-Working-Directory: '${PWD}'"
  is_git_repo=$(git rev-parse --is-inside-work-tree) # Shows Warning (But Works): fatal: not a git repository (or any of the parent directories): .git
  if [[ ${is_git_repo} == 'true' ]]
  then
	  git push
  fi

  #echo 'echo from git-push'
}

function git_fetch_pjnote() {
  cd "${note_base_path}"
  echo "Present-Working-Directory: '${PWD}'"
  is_git_repo=$(git rev-parse --is-inside-work-tree) # Shows Warning (But Works): fatal: not a git repository (or any of the parent directories): .git
  if [[ ${is_git_repo} == 'true' ]]
  then
	  git fetch
  fi

  #echo 'echo from git-fetch'
}

function git_pull_pjnote() {
  cd "${note_base_path}"
  echo "Present-Working-Directory: '${PWD}'"
  is_git_repo=$(git rev-parse --is-inside-work-tree) # Shows Warning (But Works): fatal: not a git repository (or any of the parent directories): .git
  if [[ ${is_git_repo} == 'true' ]]
  then
	  git pull
  fi

  #echo 'echo from git-pull'
}

function mkdocs_serve_pjnote() {
  if [[ $(uname -s) == 'Linux' ]] # Linux-OS
  then
    mkdocs_path="${note_base_path}${PWD}"
  else
    mkdocs_path=$(cygpath -w "${note_base_path}${PWD}")
  fi
  printf "site_name: PNote\ndocs_dir: " > "${repo_file_path}/mkdocs.yml"
  echo "'${mkdocs_path}'" >> "${repo_file_path}/mkdocs.yml"
  cd "${repo_file_path}"
  mkdocs serve --dev-addr localhost:7702
}

if [[ "$1" == "note" ]] # Script/Command: pnote
then
  if [[ "$2" == "help" ]]
  then
    help_pjnote
    exit
  fi

  note_path_id=${note_repo_list[$PWD]}
  if [[ "${note_path_id}" == '' ]]
  then
    echo 'Note: No entry for current directory in note(restic+git) repository list!'
    exit
  fi

  note_base_path_string='cat "${repo_json_file}" | jq -r ".repo_config | .note_base_path_collection | .['
  note_base_path_string+=${note_path_id}
  note_base_path_string+='] | .note_base_path"'
  note_base_path=$(eval $note_base_path_string)
  
  if [[ "${note_base_path}" == "null" ]]
  then
    echo "Note Base Path Not Found!"
    exit
  fi
  
  operating_system=$(uname -s)
  note_parent_folder="${note_base_path}${PWD}"
  if [ ! -d "${note_parent_folder}" ]
  then
    mkdir -p "${note_parent_folder}"
    echo "Created folder: ${note_parent_folder}"
  fi
  if [[ ${operating_system} == 'Linux' ]]
  then
    editor_open_command="${linux_editor} "
  else
    editor_open_command="start ${windows_editor} "
  fi

  work_type="$2"
  git_commit_message="$3"

  if [[ ${work_type} == 'create' ]]
  then
    create_pjnote
  elif [[ ${work_type} == 'open' ]]
  then
    open_pjnote
  elif [[ ${work_type} == 'rename' ]]
  then
    rename_pjnote
  elif [[ ${work_type} == 'delete' ]]
  then
    delete_pjnote
  elif [[ ${work_type} == 'about' ]]
  then
    about_file_pjnote
  elif [[ ${work_type} == 'todo' ]]
  then
    todo_file_pjnote
  elif [[ ${work_type} == 'bug' ]]
  then
    bug_file_pjnote
  elif [[ ${work_type} == 'guide' ]]
  then
    guide_file_pjnote
  elif [[ ${work_type} == 'document' ]]
  then
    document_file_pjnote
  elif [[ ${work_type} == 'password' ]]
  then
    password_file_pjnote
  elif [[ ${work_type} == 'status' ]]
  then
    git_status_pjnote  
  elif [[ ${work_type} == 'commit' ]]
  then
    git_commit_pjnote
  elif [[ ${work_type} == 'push' ]]
  then
    git_push_pjnote
  elif [[ ${work_type} == 'fetch' ]]
  then
    git_fetch_pjnote
  elif [[ ${work_type} == 'pull' ]]
  then
    git_pull_pjnote
  elif [[ ${work_type} == 'mkdocs-serve' ]]
  then
    mkdocs_serve_pjnote
  fi
  exit
fi
#----------------------------END-SCRIPT: pjnote----------------------------

#----------------------------START-SCRIPT: pjtodo----------------------------

pjtodo_help_text="project || Project management for todo.\n
record || ToDo list management.\n
attachment || Attachment management for todo.\n
comment || Comment management for todo."

pjtodo_project_help="view || View project list.\n
add || Add new project.\n
edit || Edit existing project.\n
delete || Delete existing project."

pjtodo_record_help="view || View todo list.\n
add || Add new todo.\n
edit || Edit existing todo.\n
delete || Delete existing todo."

pjtodo_attachment_help="view || View attachment list.\n
add || Add new attachment.\n
edit || Edit existing attachment.\n
delete || Delete existing attachment."

pjtodo_comment_help="view || View comment list.\n
add || Add new comment.\n
edit || Edit existing comment.\n
delete || Delete existing comment."

function store_project_pjtodo() {
    all_project_string=""
    if [[ "$OSTYPE" == 'msys' ]]
    then
        echo "Fetching Project List..."
        get_project_list=$(curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Project")
    else
        get_project_list=$(gum spin --spinner dot --title "Fetching Project List..." --show-output -- curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Project")
    fi
    get_project_list=$(escape_single_quote "${get_project_list}")
    get_project_store="${get_project_list}"
    # echo "${get_project_list}" >> "${repo_file_path}/test_project.txt"

    get_project_array=$(echo "${get_project_list}" | jq -r '.data|map("
all_project_array['\''\(.id),id'\'']='\''\(.id)'\'';
all_project_array['\''\(.id),project_name'\'']='\''\(.project_name)'\'';
all_project_array['\''\(.id),path'\'']='\''\(.path)'\'';
all_project_array['\''\(.id),about'\'']='\''\(.about)'\'';
PROJECT_ID_COLL+=('\''\(.id)'\'');
all_project_string+=\"\(.id)\\t\(.project_name)\\t\(.path)\\n\";
")|.[]')
    eval "${get_project_array}"
    all_project_string=${all_project_string%??} 
}

function store_todo_pjtodo() {
    project_id_filter="$1"
    all_todo_string=""
    if [[ "$OSTYPE" == 'msys' ]]
    then
        echo "Fetching ToDo List..."
        get_todo_list=$(curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=ToDo&project_id=${project_id_filter}")
    else
        get_todo_list=$(gum spin --spinner dot --title "Fetching ToDo List..." --show-output -- curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=ToDo&project_id=${project_id_filter}")
    fi
    get_todo_list=$(escape_single_quote "${get_todo_list}")
    get_todo_store="${get_todo_list}"
    # echo "${get_todo_list}" >> "${repo_file_path}/test_todo.txt"

    get_todo_array=$(echo "${get_todo_list}" | jq -r '.data|map("
all_todo_array['\''\(.id),id'\'']='\''\(.id)'\'';
all_todo_array['\''\(.id),project_id'\'']='\''\(.project_id)'\'';
all_todo_array['\''\(.id),category'\'']='\''\(.category)'\'';
all_todo_array['\''\(.id),created_at'\'']='\''\(.created_at)'\'';
all_todo_array['\''\(.id),completed_at'\'']='\''\(.completed_at)'\'';
all_todo_array['\''\(.id),summary'\'']='\''\(.summary)'\'';
all_todo_array['\''\(.id),description'\'']='\''\(.description)'\'';
all_todo_array['\''\(.id),status'\'']='\''\(.status)'\'';
TODO_ID_COLL+=('\''\(.id)'\'');
all_todo_string+=\"\(.id)\\t${all_project_array['\''\(.project_id),project_name'\'']}\\t\(.category)\\t\(.status)\\t\(.summary)\\n\";
")|.[]')
    eval "${get_todo_array}"
    all_todo_string=${all_todo_string%??}
}

function project_view_pjtodo() {
    store_project_pjtodo
    filtered_project_string=$(echo -e ${all_project_string} | gum filter --indicator=">" --header="Select Project To Edit: ID | Project Name | Path")
    filtered_project_array=(${filtered_project_string})
    filtered_id=${filtered_project_array[0]}
    project_id_get=${all_project_array["${filtered_id},id"]}
    project_name_get=${all_project_array["${filtered_id},project_name"]}
    path_get=${all_project_array["${filtered_id},path"]}
    about_get=${all_project_array["${filtered_id},about"]}
    echo "Project Details ->"
    project_show="KEY\tVALUE\n"
    project_show+="ID\t${project_id_get}\n"
    project_show+="Project Name\t${project_name_get}\n"
    project_show+="Project Path\t${path_get}\n"
    project_show+="About Project\t${about_get}\n"
    printf "${project_show}" | prettytable 2
}

function project_add_pjtodo() {
    echo "Add Project ->"
    project_name_input=$(escapejc "$(gum input --header="Enter Project Name" --placeholder="Write Project Name")")
    path_input=$(escapejc "$(gum input --header="Enter Project Path" --placeholder="Write Project Path")")
    about_input=$(escapejc "$(gum write --header="Enter About Project" --placeholder="Write About Project")")

    insert_feedback=$(gum spin --spinner dot --title "Adding Project..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"project_name\\\":\\\"${project_name_input}\\\", \\\"path\\\": \\\"${path_input}\\\", \\\"about\\\":\\\"${about_input}\\\"}\"" "${gapps_url}?action=insert&table=Project")
    echo "${insert_feedback}" | jq
}

function project_edit_pjtodo() {
    store_project_pjtodo
    filtered_project_string=$(echo -e ${all_project_string} | gum filter --indicator=">" --header="Select Project To Edit: ID | Project Name | Path")
    filtered_project_array=(${filtered_project_string})
    filtered_id=${filtered_project_array[0]}
    project_id_edit=${all_project_array["${filtered_id},id"]}
    project_name_edit=${all_project_array["${filtered_id},project_name"]}
    path_edit=${all_project_array["${filtered_id},path"]}
    about_edit=${all_project_array["${filtered_id},about"]}
    
    echo "Edit Project ->"
    project_name_input=$(escapejc "$(gum input --header="Enter Project Name" --placeholder="Write Project Name"  --value="${project_name_edit}")")
    path_input=$(escapejc "$(gum input --header="Enter Project Path" --placeholder="Write Project Path" --value="${path_edit}")")
    about_input=$(escapejc "$(gum write --header="Enter About Project" --placeholder="Write About Project" --value="${about_edit}")")

    update_feedback=$(gum spin --spinner dot --title "Updating Project (ID-${project_id_edit})..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"project_name\\\":\\\"${project_name_input}\\\", \\\"path\\\": \\\"${path_input}\\\", \\\"about\\\":\\\"${about_input}\\\"}\"" "${gapps_url}?action=update&table=Project&id=${project_id_edit}")
    echo "${update_feedback}" | jq
}

function project_delete_pjtodo() {
    store_project_pjtodo
    filtered_project_string=$(echo -e ${all_project_string} | gum filter --indicator=">" --header="Select Project To Delete: ID | Project Name | Path")
    filtered_project_array=(${filtered_project_string})
    filtered_id=${filtered_project_array[0]}
    project_id_delete=${all_project_array["${filtered_id},id"]}
    project_name_delete=${all_project_array["${filtered_id},project_name"]}
    path_delete=${all_project_array["${filtered_id},path"]}
    about_delete=${all_project_array["${filtered_id},about"]}
    echo "Delete Project ->"
    project_show="  KEY\tVALUE\n"
    project_show+="  ID\t${project_id_delete}\n"
    project_show+="  Project Name\t${project_name_delete}\n"
    project_show+="  Project Type\t${path_delete}\n"
    project_show+="  About Project\t${about_delete}\n"
    printf "${project_show}" | prettytable 2

    confirm_delete=$(gum confirm --default="No" "Delete This Project?" && echo "yes" || echo "no")
    if [[ ${confirm_delete} == 'yes' ]]
    then
        delete_feedback=$(gum spin --spinner dot --title "Deleting Project (ID-${project_id_delete})..." --show-output -- curl -L -H "application/json" -d '' "${gapps_url}?action=delete&table=Project&id=${project_id_delete}")
        echo "${delete_feedback}" | jq
    fi
}

function todo_view_pjtodo() {
    filtered_id=$1
    todo_id_get=${all_todo_array["${filtered_id},id"]}
    project_id_get=${all_todo_array["${filtered_id},project_id"]}
    category_get=${all_todo_array["${filtered_id},category"]}
    created_at_get=${all_todo_array["${filtered_id},created_at"]}
    completed_at_get=${all_todo_array["${filtered_id},completed_at"]}
    summary_get=${all_todo_array["${filtered_id},summary"]}
    description_get=${all_todo_array["${filtered_id},description"]}
    status_get=${all_todo_array["${filtered_id},status"]}
    project_name_get=${all_project_array["${project_id_get},project_name"]}
    echo "ToDo Details ->"
    todo_show="KEY\tVALUE\n"
    todo_show+="ID\t${todo_id_get}\n"
    todo_show+="Project Name\t${project_name_get}\n"
    todo_show+="Category\t${category_get}\n"
    todo_show+="Created At\t${created_at_get}\n"
    todo_show+="Completed At\t${completed_at_get}\n"
    todo_show+="Summary\t${summary_get}\n"
    todo_show+="Description\t${description_get}\n"
    todo_show+="Status\t${status_get}\n"
    printf "${todo_show}" | prettytable 2
}

function todo_view_filter_pjtodo() {
    store_project_pjtodo
    filtered_project_string=$(echo -e ${all_project_string} | gum filter --indicator=">" --header="Select Project To Edit: ID | Project Name | Path")
    filtered_project_array=(${filtered_project_string})
    filtered_project_id=${filtered_project_array[0]}
    store_todo_pjtodo "${filtered_project_id}"

    filter_by="$1"
    todo_remain_string=""
    todo_completed_string=""
    for each_id in "${TODO_ID_COLL[@]}"; do
        todo_id=${all_todo_array["${each_id},id"]}
        project_id=${all_todo_array["${each_id},project_id"]}
        category=${all_todo_array["${each_id},category"]}
        created_at=${all_todo_array["${each_id},created_at"]}
        completed_at=${all_todo_array["${each_id},completed_at"]}
        summary=${all_todo_array["${each_id},summary"]}
        description=${all_todo_array["${each_id},description"]}
        status=${all_todo_array["${each_id},status"]}
        project_name=${all_project_array["${project_id},project_name"]}

        if [[ ${filter_by} == 'remain' ]]
        then
            todo_remain_string+="${todo_id}\t${project_name}\t${category}\t${status}\t${summary}\n"
        elif [[ ${filter_by} == 'completed' ]]
        then
            todo_completed_string+="${todo_id}\t${project_name}\t${category}\t${status}\t${summary}\n"
        fi
    done

    if [[ ${filter_by} == 'all' ]]
    then
        filtered_todo_string=$(echo -e ${all_todo_string} | gum filter --indicator=">" --header="ToDo View: ID | Project Name | Category | Status | Summary")
    elif [[ ${filter_by} == 'remain' ]]
    then
        filtered_todo_string=$(echo -e ${todo_remain_string} | gum filter --indicator=">" --header="ToDo View: ID | Project Name | Category | Status | Summary")
    elif [[ ${filter_by} == 'completed' ]]
    then
        filtered_todo_string=$(echo -e ${todo_completed_string} | gum filter --indicator=">" --header="ToDo View: ID | Project Name | Category | Status | Summary")
    fi
    filtered_todo_array=(${filtered_todo_string})
    filtered_id=${filtered_todo_array[0]}
    todo_view_pjtodo ${filtered_id}
}

if [[ "$1" == 'todo' ]] # Script/Command: "todo"
then
    if [[ "$2" == 'help' ]]
    then
        help_pjtodo
        exit
    fi

    all_project_string=""
    declare -A all_project_array
    all_todo_string=""
    declare -A all_todo_array
    get_project_store=""
    get_todo_store=""
    work_type="$2"
    action="$3"
    criteria="$4"
    case ${work_type} in
        'project')
            case ${action} in
                'view')
                    project_view_pjtodo;;
                'add')
                    project_add_pjtodo;;
                'edit')
                    project_edit_pjtodo;;
                'delete')
                    project_delete_pjtodo;;
            esac;;
        'record') # ToDo Records
            case ${action} in
                'view')
                    todo_view_filter_pjtodo 'remain';;
                'add')
                    todo_add_pjtodo;;
                'edit')
                    todo_edit_pjtodo;;
                'delete')
                    todo_delete_pjtodo;;
            esac;;
        'attachment')
            case ${action} in
                'view')
                    attachment_view_pjtodo;;
                'add')
                    attachment_add_pjtodo;;
                'edit')
                    attachment_edit_pjtodo;;
                'delete')
                    attachment_delete_pjtodo;;
            esac;;
        'comment')
            case ${action} in
                'view')
                    comment_view_pjtodo;;
                'add')
                    comment_add_pjtodo;;
                'edit')
                    comment_edit_pjtodo;;
                'delete')
                    comment_delete_pjtodo;;
            esac;;
    esac
    exit
fi

#----------------------------END-SCRIPT: pjtodo----------------------------

#----------------------------START-SCRIPT: db-sync----------------------------

dbsync_help_text="backup || Backup database to local-pc and cloud. Optional database archive.\n
restore || Restore database.\n
fetch || Fetch database from cloud to local-pc."

function help_dbsync() {
  printf "Usage:\njjkk dbsync (development-env) [command]
  (development-env): xampp/docker/vagrant development environment.\n\nAvailabe Commands:\n"
  printf "${dbsync_help_text}" | column --table --separator "||"
}

function db_backup_dbsync() {
  is_git_repo=$(git rev-parse --is-inside-work-tree) # Shows Warning (But Works): fatal: not a git repository (or any of the parent directories): .git
  if [[ ${is_git_repo} == 'true' ]]
  then
    git_commit_id=$(git rev-parse --short HEAD)
	  git_commit_id="_${git_commit_id}"
  else
    git_commit_id=''
  fi

  db_backup_folder="${db_sync_local_base_path}${PWD}"
  db_file_backup="${current_date_time}_${database_name}${git_commit_id}.sql"
  if [ ! -d "${db_backup_folder}" ]
  then
    mkdir -p "${db_backup_folder}"
  fi
  
  eval rm "${db_backup_folder}/*"

  if [[ "${enable_db_archive}" == "yes" ]]
  then
    db_archive_folder="${db_archive_base_path}${PWD}"
    if [ ! -d "${db_archive_folder}" ]
    then
      mkdir -p "${db_archive_folder}"
    fi
  fi

  if [[ ${development_env} == 'xampp' ]]
  then
    ${mysqldump_path} --routines -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} > "${db_backup_folder}/${db_file_backup}"
    if [[ "${enable_db_archive}" == "yes" ]]
    then
      ${mysqldump_path} --routines -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} | gzip > "${db_archive_folder}/${db_file_backup}.gz"
    fi

  elif [[ ${development_env} == 'docker' ]]
  then
    read -p "Enter MySQL/MariaDB Container Name: `echo $'\n> '`" mysql_container
    sudo docker exec -it ${mysql_container} sh -c "${mysqldump_path} --routines -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} > \"/home/${db_file_backup}\""
    sudo docker cp ${mysql_container}:"/home/${db_file_backup}" "${db_backup_folder}/${db_file_backup}"
    if [[ "${enable_db_archive}" == "yes" ]]
    then
      sudo docker exec -it ${mysql_container} sh -c "${mysqldump_path} --routines -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} | gzip > \"/home/${db_file_backup}.gz\""
      sudo docker cp ${mysql_container}:"/home/${db_file_backup}.gz" "${db_archive_folder}/${db_file_backup}.gz"
    fi
    sudo docker exec -it ${mysql_container} sh -c "rm /home/*.sql"

  elif [[ ${development_env} == 'vagrant' ]]
  then
    echo 'DB-Sync: Vagrant-Backup has not impemented yet.'
	exit
  fi
  
  rclone purge "${rclone_remote_name}:${database_sync_remote_base}${PWD}" --verbose
  rclone mkdir "${rclone_remote_name}:${database_sync_remote_base}${PWD}" --verbose
  rclone copyto "${db_backup_folder}/${db_file_backup}" "${rclone_remote_name}:${database_sync_remote_base}${PWD}/${db_file_backup}" --progress

  echo "DB-Sync: Database backup created successfully."
}

function db_fetch_dbsync() {
  db_fetch_folder="${db_sync_local_base_path}${PWD}"
  if [ ! -d "${db_fetch_folder}" ]
  then
    mkdir -p "${db_fetch_folder}"
  fi
  eval rm "${db_fetch_folder}/*"

  rclone_changed_files=$(rclone ls "${rclone_remote_name}:${database_sync_remote_base}${PWD}" | awk '{sub(/[^ ]+[ ]+/,"")}1') # https://stackoverflow.com/questions/14327442/treat-second-column-with-spaces-as-one-column-with-awk
  #echo "${rclone_changed_files}"
  
  IFS=$'\n' 
  read -rd '' -a rclone_changed_files_array <<<"$rclone_changed_files"
  unset IFS
  
  for ((rclone_changed_inc = 0; rclone_changed_inc < ${#rclone_changed_files_array[@]}; rclone_changed_inc++))
  do
    # https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
    var="${rclone_changed_files_array[$rclone_changed_inc]}"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   
    #printf '%s' "$var"
    #${rclone_changed_files_array[$rclone_changed_inc]}="${var}"
	#echo "${var}"
  
    rclone copyto "${rclone_remote_name}:${database_sync_remote_base}${PWD}/${var}" "${db_sync_local_base_path}${PWD}/${var}" --progress
    #echo "${rclone_changed_files_array[$rclone_changed_inc]}"
  done

  echo "DB-Sync: Database fetched successfully."
}

function db_restore_dbsync() {
  original_pwd="${PWD}"
  db_restore_folder="${db_sync_local_base_path}${PWD}"
  cd "${db_restore_folder}"
  file_list_array=( * ) # Shell glob-pattern
  db_file_restore=${file_list_array[0]}
  cd "${original_pwd}"
  
  read -p "Do you want to open database file (yes/no): `echo $'\n> '`" confirm_db_file_open
  if [[ ${confirm_db_file_open} == 'yes' ]]
  then
    ${editor_open_command}"${db_restore_folder}/${db_file_restore}"
  fi
  
  read -p "Do you want to restore database '${db_restore_folder}/${db_file_restore}' (yes-restore-db/no): `echo $'\n> '`" confirm_db_restore
  if [[ ${confirm_db_restore} == 'yes-restore-db'  ]]
  then
    echo ''
  else
    echo "DB-Sync: You rejected to restore database."
    exit
  fi
  
  if [[ ${development_env} == 'xampp' ]]
  then
    ${mysql_path} -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} < "${db_restore_folder}/${db_file_restore}"	

  elif [[ ${development_env} == 'docker' ]]
  then
    read -p "Enter MySQL/MariaDB Container Name: `echo $'\n> '`" mysql_container
    sudo docker cp "${db_restore_folder}/${db_file_restore}" ${mysql_container}:"/home/${db_file_restore}"
    sudo docker exec -it ${mysql_container} sh -c "${mysql_path} -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} < \"/home/${db_file_restore}\""
    sudo docker exec -it ${mysql_container} sh -c "rm /home/*.sql"

	exit
  elif [[ ${development_env} == 'vagrant' ]]
  then
    echo 'DB-Sync: Vagrant-Restore has not impemented yet.'
	exit
  fi

  echo "DB-Sync: Database restored successfully."
}

if [[ "$1" == "dbsync" ]] # Script/Command: "db-sync"
then
  if [[ "$2" == "help" ]]
  then
    help_dbsync
    exit
  fi

  development_env="$2" # Development Environment: xampp/docker/vagrant
  work_type="$3" # Work Type: backup/restore/fetch
  current_date_time=$(date '+%Y-%m-%d_%H%M%S')
  #echo "${current_date_time}"

  if [[ ( ${development_env} != 'xampp' && ${development_env} != 'docker' && ${development_env} != 'vagrant' ) || ( ${work_type} != 'backup' && ${work_type} != 'restore' && ${work_type} != 'fetch' ) ]]
  then
    echo "DB-Sync: Please Provide Argument-1 (xampp/docker/vagrant) and Argument-2 (backup/restore/fetch)"
    exit
  fi

  get_git_repo=${git_repo_list[$PWD]}
  if [[ ${get_git_repo} != '' ]]
  then
    get_git_repo_array=(${get_git_repo})
    git_repo_url=${get_git_repo_array[0]}
    rclone_remote_name=${get_git_repo_array[1]}
    composer_do_download=${get_git_repo_array[2]} # PHP Composer
    npm_do_download=${get_git_repo_array[3]} # Node Package Manager (NPM)
    database_name=${get_git_repo_array[4]}
    # Check database name exists or not
    if [[ ${database_name} == 'N/A' ]]
    then
      echo "DB-Sync: Database name is 'N/A' for current project"
	    exit
    fi
    # Check "rclone" remote exists or not
    if [[ $(rclone listremotes | grep "${rclone_remote_name}:") != "${rclone_remote_name}:" ]]
    then
      echo -e "\033[41mRclone: ${rclone_remote_name} does not exist! Add it using command -- rclone config\033[m"
      exit
    fi
    if [[ ${work_type} == 'backup' || ${work_type} == 'restore' ]]
    then
      read -p "Enter database user name: `echo $'\n> '`" db_user_name
      read -p "Enter database password: `echo $'\n> '`" db_password
      echo "DB Host Name: ${db_host_name}; Database Name: ${database_name}; DB User Name: ${db_user_name}; DB Password: ${db_password}"
    fi
  else
    echo 'DB-Sync: No entry for current directory in git repository list!'
    exit
  fi

  operating_system=$(uname -s)
  if [[ ${development_env} == 'xampp' ]]
  then
    if [[ ${operating_system} == 'Linux' ]]
    then
      mysqldump_path=''
      mysql_path=''
	    editor_open_command="${linux_editor} "
    else # Windows-OS
      mysqldump_path='../../mysql/bin/mysqldump.exe'
      mysql_path='../../mysql/bin/mysql.exe'
	    editor_open_command="start ${windows_editor} "
    fi
  elif [[ ${development_env} == 'docker' ]]
  then
    mysqldump_path='mysqldump' # LaraDock
    mysql_path='mysql' # LaraDock
    editor_open_command="${linux_editor} "
    sudo docker container ls --filter "name=mysql" --filter "name=mariadb"
  elif [[ ${development_env} == 'vagrant' ]]
  then
    mysqldump_path='/bin/mysqldump' # Laravel-Homestead
    mysql_path='/bin/mysql' # Laravel-Homestead
  fi

  if [[ ${work_type} == 'backup' ]]
  then
    db_backup_dbsync
  elif [[ ${work_type} == 'restore' ]]
  then
    db_fetch_dbsync
    db_restore_dbsync
  elif [[ ${work_type} == 'fetch' ]]
  then
    db_fetch_dbsync
  fi
  exit
fi
#----------------------------END-SCRIPT: db-sync----------------------------

#----------------------------START-SCRIPT: dbackup----------------------------

dbackup_help_text="backup || [--full-db] Backup database structure and specific data at project path \"__database\" folder.\n
restore || Restore full database from project path \"__database\" folder.\n
php || [command] Execute php command using specific php version.\n
setup || Setup php/composer environment.\n
generate || [table] [row-count] Generate database data using php-faker."

function help_dbackup() {
  printf "Usage:\njjkk dbackup (development-env) [command]
  (development-env): xampp/docker/vagrant development environment.\n\nAvailabe Commands:\n"
  printf "${dbackup_help_text}" | column --table --separator "||"
}

function db_backup_dbackup() {
  if [ ! -d "${base_path}/structure" ]
  then
    mkdir -p "${base_path}/structure"
  fi
  if [ ! -d "${base_path}/data" ]
  then
    mkdir -p "${base_path}/data"
  fi
  if [[ ${db_full_backup} == 'yes' ]]
  then
    if [ ! -d "${base_path}/full" ]
	  then
	    mkdir -p "${base_path}/full"
	  fi
  fi
  #eval rm "${base_path}/data/*"

  if [[ ${development_env} == 'xampp' ]]
  then
    ${mysqldump_path} --routines --no-data --compact -h "${db_host_name}" -u "${db_user_name}" -p"${db_password}" "${database_name}" > "${base_path}/structure/${database_name}(structure).sql"
	  if [[ ${db_full_backup} == 'yes' ]]
	  then
	    ${mysqldump_path} --routines -h "${db_host_name}" -u "${db_user_name}" -p"${db_password}" "${database_name}" > "${base_path}/full/${database_name}(full).sql"
	  fi
	  eval "${mysqldump_path} --routines --no-create-info --compact -h \"${db_host_name}\" -u \"${db_user_name}\" -p\"${db_password}\" \"${database_name}\" ${dump_table_data} > \"${base_path}/data/${database_name}(data).sql\""

  elif [[ ${development_env} == 'docker' ]]
  then
    read -p "Enter MySQL/MariaDB Container Name: `echo $'\n> '`" mysql_container
    sudo docker exec -it ${mysql_container} sh -c "${mysqldump_path} --routines --no-data --compact -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} > \"/home/${database_name}(structure).sql\""
    sudo docker cp ${mysql_container}:"/home/${database_name}(structure).sql" "./__database/structure/${database_name}(structure).sql"
    if [[ ${db_full_backup} == 'yes' ]]
    then
      sudo docker exec -it ${mysql_container} sh -c "${mysqldump_path} --routines -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} > \"/home/${database_name}(full).sql\""
      sudo docker cp ${mysql_container}:"/home/${database_name}(full).sql" "./__database/full/${database_name}(full).sql"
    fi
    sudo docker exec -it ${mysql_container} sh -c "${mysqldump_path} --routines --no-create-info --compact -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} ${dump_table_data} > \"/home/${database_name}(data).sql\""
    sudo docker cp ${mysql_container}:"/home/${database_name}(data).sql" "./__database/data/${database_name}(data).sql"
    sudo docker exec -it ${mysql_container} sh -c "rm /home/*.sql"

  elif [[ ${development_env} == 'vagrant' ]]
  then
    echo 'Vagrant-Backup has not impemented yet.'
  fi
  echo "DBackup: Database backup completed successfully."
}

function db_restore_dbackup() {
  db_restore_file_path="${base_path}/full/${database_name}(full).sql"
  if [[ ! -f "${db_restore_file_path}" ]]
  then
    echo "DBackup: Database sql file does not exist at: '${db_restore_file_path}'"
    exit
  fi
  read -p "Do you want to restore DB '${db_restore_file_path}'? (yes/no) `echo $'\n> '`" restore_confirm
  if [[ "${restore_confirm}" != 'yes' ]]
  then
    echo "DBackup: You have rejected to restore database!"
    exit
  fi

  if [[ ${development_env} == 'xampp' ]]
  then
    ${mysql_path} -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} < "${db_restore_file_path}"

  elif [[ ${development_env} == 'docker' ]]
  then
    read -p "Enter MySQL/MariaDB Container Name: `echo $'\n> '`" mysql_container
    sudo docker cp ${db_restore_file_path} ${mysql_container}:"/home/${database_name}(full).sql"
    sudo docker exec -it ${mysql_container} sh -c "${mysql_path} -h ${db_host_name} -u ${db_user_name} -p${db_password} ${database_name} < \"/home/${database_name}(full).sql\""
    sudo docker exec -it ${mysql_container} sh -c "rm /home/*.sql"
  fi
  echo "DBackup: Database restored successfully."
}

function php_execute_dbackup() {
  php_command="$1"
  ${php_path} ${php_command}
}

#function composer_execute_dbackup() {}

function setup_environment_dbackup() {
  # Setup Composer
  ${php_path} -r "copy('https://getcomposer.org/installer', '${base_path}/composer-setup.php');"
  ${php_path} -r "if (hash_file('sha384', '${base_path}/composer-setup.php') === '55ce33d7678c5a611085589f1f3ddf8b3c52d662cd01d4ba75c0ee0459970c2200a51f492d557530c71c15d8dba01eae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('${base_path}/composer-setup.php'); } echo PHP_EOL;"
  ${php_path} ${base_path}/composer-setup.php --install-dir="${base_path}"
  ${php_path} -r "unlink('${base_path}/composer-setup.php');"
 
  # Setup [FakerPHP/Faker](https://github.com/FakerPHP/Faker)
  ${php_path} "${base_path}/composer.phar" --working-dir="${base_path}" require fakerphp/faker
}

function generate_data_dbackup {
  table_name="$1"
  row_number="$2"
  if [[ "${table_name}" == '' || "${row_number}" == '' ]]
  then
    echo "Wrong Input! Enter both table-name and row-number."
	  exit
  fi
  ${php_path} "${base_path}/generate-data.php" "${table_name}" "$row_number"
  #echo "Data generated successfully."
}

if [[ "$1" == "dbackup" ]] # Script/Command: "dbackup"
then
  if [[ "$2" == "help" ]]
  then
    help_dbackup
    exit
  fi

  base_path="${PWD}/__database"
  if [[ ! -f "${base_path}/config" ]]
  then
    echo "DBackup: Config file does not exist at: '${base_path}/config'"
    exit
  fi

  source "${base_path}/config"
  #dump_table_data="'table 1' 'table 2'"
  echo "DB Host Name: ${db_host_name}; DB User Name: ${db_user_name}; DB Password: ${db_password}; Database Name: ${database_name}; Dump Table Data: ${dump_table_data}"

  development_env="$2" # Development Environment: xampp/docker/vagrant
  work_type="$3" # Work Type: backup/restore/fetch

  if [[ ( ${development_env} != 'xampp' && ${development_env} != 'docker' && ${development_env} != 'vagrant' ) || ( ${work_type} != 'backup' && ${work_type} != 'restore' && ${work_type} != 'php' && ${work_type} != 'setup' && ${work_type} != 'generate' ) ]]
  then
    echo "DBackup: Please Provide Argument-1 (xampp/docker/vagrant) and Argument-2 (backup/php/setup)"
    exit
  fi

  operating_system=$(uname -s)
  if [[ ${development_env} == 'xampp' ]]
  then
    if [[ ${operating_system} == 'Linux' ]]
    then
      mysqldump_path=''
      mysql_path=''
	    php_path=''
	    editor_open_command="${linux_editor} "
    else # Windows-OS
      mysqldump_path='../../mysql/bin/mysqldump.exe'
      mysql_path='../../mysql/bin/mysql.exe'
	    php_path='../../php/php.exe'
	    editor_open_command="start ${windows_editor} "
    fi
  elif [[ ${development_env} == 'docker' ]]
  then
    mysqldump_path='mysqldump' # LaraDock
    mysql_path='mysql' # LaraDock
    sudo docker container ls --filter "name=mysql" --filter "name=mariadb"
  elif [[ ${development_env} == 'vagrant' ]]
  then
    mysqldump_path='/bin/mysqldump' # Laravel-Homestead
    mysql_path='/bin/mysql' # Laravel-Homestead
  fi

  db_full_backup='no'
  if [[ "$4" == '--full-db' ]]
  then
    db_full_backup='yes'
  fi 

  if [[ ${work_type} == 'backup' ]]
  then
    db_backup_dbackup
  elif [[ ${work_type} == 'restore' ]]
  then
    db_restore_dbackup
  elif [[ ${work_type} == 'php' ]]
  then
    php_execute_dbackup "$4"
  elif [[ ${work_type} == 'setup' ]]
  then
    setup_environment_dbackup
  elif [[ ${work_type} == 'generate' ]]
  then
    generate_data_dbackup "$4" "$5"
  fi
  exit
fi
#----------------------------END-SCRIPT: dbackup----------------------------

#----------------------------START-SCRIPT: pcsync----------------------------

pcsync_help_text="device || Device management for pcsync.\n
task || Task management for pcsync."

pcsync_device_help="view || View device list.\n
add || Add new device.\n
edit || Edit existing device.\n
delete || Delete existing device."

pcsync_task_help="view || View a task from all task list.\n
sview || View a task from device based task list.\n
add || Add new task.\n
edit || Edit a task from all task list.\n
sedit || Edit a task from device based task list.\n
delete || Delete a task from all task list.\n
sdelete || Delete a task from device based task list.\n
download || Download device and task list. Used to run command.\n
vcmd || View all command of specific device.\n
drun || Dry-Run command of specific device.\n
frun || Final-Run command of specific device.\n
srun || Selectively-Run command of specific device."

function help_pcsync() {
    printf "Usage:\njjkk pcsync [command]\n\nAvailabe Commands:\n"
    printf "${pcsync_help_text}" | column --table --separator "||"
    printf "\nDevice Management Commands:\n"
    printf "${pcsync_device_help}" | column --table --separator "||"
    printf "\nTask Management Commands:\n"
    printf "${pcsync_task_help}" | column --table --separator "||"
}

function store_device_pcsync() {
    all_device_string=""
    if [[ "$OSTYPE" == 'msys' ]]
    then
        echo "Fetching Device List..."
        get_device_list=$(curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Device")
    else
        get_device_list=$(gum spin --spinner dot --title "Fetching Device List..." --show-output -- curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Device")
    fi
    get_device_list=$(escape_single_quote "${get_device_list}")
    get_device_store="${get_device_list}"
    # echo "${get_device_list}" >> "${repo_file_path}/test_device.txt"

    get_device_array=$(echo "${get_device_list}" | jq -r '.data|map("
all_device_array['\''\(.id),id'\'']='\''\(.id)'\'';
all_device_array['\''\(.id),device_name'\'']='\''\(.device_name)'\'';
all_device_array['\''\(.id),device_type'\'']='\''\(.device_type)'\'';
all_device_array['\''\(.id),ip_address'\'']='\''\(.ip_address)'\'';
all_device_array['\''\(.id),ssh_user'\'']='\''\(.ssh_user)'\'';
all_device_array['\''\(.id),ssh_port'\'']='\''\(.ssh_port)'\'';
all_device_array['\''\(.id),base_path'\'']='\''\(.base_path)'\'';
DEVICE_ID_COLL+=('\''\(.id)'\'');
all_device_string+=\"\(.id)\\t\(.device_name)\\t\(.device_type)\\t\(.ip_address)\\t\(.ssh_user)\\t\(.ssh_port)\\n\";
")|.[]')
    eval "${get_device_array}"
    all_device_string=${all_device_string%??}
}

function store_task_pcsync() {
    all_task_string=""
    if [[ "$OSTYPE" == 'msys' ]]
    then
        echo "Fetching Task List..."
        get_task_list=$(curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Task")
    else
        get_task_list=$(gum spin --spinner dot --title "Fetching Task List..." --show-output -- curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Task")
    fi
    get_task_list=$(escape_single_quote "${get_task_list}")
    get_task_store="${get_task_list}"
    # echo "${get_task_list}" >> "${repo_file_path}/test_task.txt"

    get_task_array=$(echo "${get_task_list}" | jq -r '.data|map("
all_task_array['\''\(.id),id'\'']='\''\(.id)'\'';
all_task_array['\''\(.id),task_type'\'']='\''\(.task_type)'\'';
all_task_array['\''\(.id),use_program'\'']='\''\(.use_program)'\'';
all_task_array['\''\(.id),program_duty'\'']='\''\(.program_duty)'\'';
all_task_array['\''\(.id),cmd_argument'\'']='\''\(.cmd_argument)'\'';
all_task_array['\''\(.id),working_device'\'']='\''\(.working_device)'\'';
all_task_array['\''\(.id),pwd_path'\'']='\''\(.pwd_path)'\'';
all_task_array['\''\(.id),transfer_from'\'']='\''\(.transfer_from)'\'';
all_task_array['\''\(.id),transfer_to'\'']='\''\(.transfer_to)'\'';
all_task_array['\''\(.id),from_path'\'']='\''\(.from_path)'\'';
all_task_array['\''\(.id),to_path'\'']='\''\(.to_path)'\'';
all_task_array['\''\(.id),flip_path'\'']='\''\(.flip_path)'\'';
all_task_array['\''\(.id),rclone_name'\'']='\''\(.rclone_name)'\'';
all_task_array['\''\(.id),last_run'\'']='\''\(.last_run)'\'';
TASK_ID_COLL+=('\''\(.id)'\'');
all_task_string+=\"\(.id)\\t\(.task_type)\\t\(.use_program)\\t\(.program_duty)\\t${all_device_array['\''\(.working_device),device_name'\'']}\\t${all_device_array['\''\(.transfer_from),device_name'\'']}\\t${all_device_array['\''\(.transfer_to),device_name'\'']}\\n\";
")|.[]')
    eval "${get_task_array}"
    all_task_string=${all_task_string%??}
}

function device_view_pcsync() {
    store_device_pcsync
    device_list_show="ID\tDevice Name\tDevice Type\tIP Address\tSSH User\tSSH Port\tBase Path\n"
    for each_id in "${DEVICE_ID_COLL[@]}"; do
        if [[ ${each_id} == 0 ]]; then continue; fi
        device_id_get=${all_device_array["${each_id},id"]}
        device_name_get=${all_device_array["${each_id},device_name"]}
        device_type_get=${all_device_array["${each_id},device_type"]}
        ip_address_get=${all_device_array["${each_id},ip_address"]}
        ssh_user_get=${all_device_array["${each_id},ssh_user"]}
        ssh_port_get=${all_device_array["${each_id},ssh_port"]}
        base_path_get=${all_device_array["${each_id},base_path"]}
        if [[ "${ip_address_get}" == "${this_device_ip}" ]]
        then
            device_list_show+=">>"
        fi
        device_list_show+="${device_id_get}\t${device_name_get}\t${device_type_get}\t${ip_address_get}\t${ssh_user_get}\t${ssh_port_get}\t${base_path_get}\n"
    done
    device_list_show=${device_list_show%??}
    printf "${device_list_show}" | prettytable 7    
}

function device_add_pcsync() {
    echo "Add Device ->"
    device_name_input=$(escapejc "$(gum input --header="Enter Device Name" --placeholder="Write Device Name")")
    device_type_input=$(escapejc "$(gum choose --header="Select Device Type" "computer" "mobile" "storage")")
    ip_address_input=$(escapejc "$(gum input --header="Enter IP Address" --placeholder="Write IP Address")")
    ssh_user_input=$(escapejc "$(gum input --header="Enter SSH User" --placeholder="Write SSH User")")
    ssh_port_input=$(escapejc "$(gum input --header="Enter SSH Port" --placeholder="Write SSH Port")")
    base_path_input=$(escapejc "$(gum input --header="Enter Base Path" --placeholder="Write Base Path")")

    insert_feedback=$(gum spin --spinner dot --title "Adding Device..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"device_name\\\":\\\"${device_name_input}\\\", \\\"device_type\\\": \\\"${device_type_input}\\\", \\\"ip_address\\\":\\\"${ip_address_input}\\\", \\\"ssh_user\\\":\\\"${ssh_user_input}\\\", \\\"ssh_port\\\":\\\"${ssh_port_input}\\\", \\\"base_path\\\":\\\"${base_path_input}\\\"}\"" "${gapps_url}?action=insert&table=Device")
    echo "${insert_feedback}" | jq
}

function device_edit_pcsync() {
    store_device_pcsync
    filtered_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select Device To Edit: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    filtered_device_array=(${filtered_device_string})
    filtered_id=${filtered_device_array[0]}
    device_id_edit=${all_device_array["${filtered_id},id"]}
    device_name_edit=${all_device_array["${filtered_id},device_name"]}
    device_type_edit=${all_device_array["${filtered_id},device_type"]}
    ip_address_edit=${all_device_array["${filtered_id},ip_address"]}
    ssh_user_edit=${all_device_array["${filtered_id},ssh_user"]}
    ssh_port_edit=${all_device_array["${filtered_id},ssh_port"]}
    base_path_edit=${all_device_array["${filtered_id},base_path"]}
    if [[ ${device_id_edit} == 0 ]]
    then
        echo -e "\033[1;31m Can Not Edit \"NO DEVICE\"! \033[0m"
        exit
    fi
    echo "Edit Device ->"
    device_name_input=$(escapejc "$(gum input --header="Enter Device Name" --placeholder="Write Device Name"  --value="${device_name_edit}")")
    device_type_input=$(escapejc "$(gum choose --header="Select Device Type" --selected="${device_type_edit}" "computer" "mobile" "storage")")
    ip_address_input=$(escapejc "$(gum input --header="Enter IP Address" --placeholder="Write IP Address" --value="${ip_address_edit}")")
    ssh_user_input=$(escapejc "$(gum input --header="Enter SSH User" --placeholder="Write SSH User" --value="${ssh_user_edit}")")
    ssh_port_input=$(escapejc "$(gum input --header="Enter SSH Port" --placeholder="Write SSH Port" --value="${ssh_port_edit}")")
    base_path_input=$(escapejc "$(gum input --header="Enter Base Path" --placeholder="Write Base Path" --value="${base_path_edit}")")

    update_feedback=$(gum spin --spinner dot --title "Updating Device (ID-${device_id_edit})..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"device_name\\\":\\\"${device_name_input}\\\", \\\"device_type\\\": \\\"${device_type_input}\\\", \\\"ip_address\\\":\\\"${ip_address_input}\\\", \\\"ssh_user\\\":\\\"${ssh_user_input}\\\", \\\"ssh_port\\\":\\\"${ssh_port_input}\\\", \\\"base_path\\\":\\\"${base_path_input}\\\"}\"" "${gapps_url}?action=update&table=Device&id=${device_id_edit}")
    echo "${update_feedback}" | jq
}

function device_delete_pcsync() {
    store_device_pcsync
    filtered_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select Device To Delete: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    filtered_device_array=(${filtered_device_string})
    filtered_id=${filtered_device_array[0]}
    device_id_delete=${all_device_array["${filtered_id},id"]}
    device_name_delete=${all_device_array["${filtered_id},device_name"]}
    device_type_delete=${all_device_array["${filtered_id},device_type"]}
    ip_address_delete=${all_device_array["${filtered_id},ip_address"]}
    ssh_user_delete=${all_device_array["${filtered_id},ssh_user"]}
    ssh_port_delete=${all_device_array["${filtered_id},ssh_port"]}
    base_path_delete=${all_device_array["${filtered_id},base_path"]}
    if [[ ${device_id_delete} == 0 ]]
    then
        echo -e "\033[1;31m Can Not Delete \"NO DEVICE\"! \033[0m"
        exit
    fi
    echo "Delete Device ->"
    device_show="  KEY\tVALUE\n"
    device_show+="  ID\t${device_id_delete}\n"
    device_show+="  Device Name\t${device_name_delete}\n"
    device_show+="  Device Type\t${device_type_delete}\n"
    device_show+="  IP Address\t${ip_address_delete}\n"
    device_show+="  SSH User\t${ssh_user_delete}\n"
    device_show+="  SSH Port\t${ssh_port_delete}\n"
    device_show+="  Base Path\t${base_path_delete}"
    printf "${device_show}" | prettytable 2

    confirm_delete=$(gum confirm --default="No" "Delete This Device?" && echo "yes" || echo "no")
    if [[ ${confirm_delete} == 'yes' ]]
    then
        delete_feedback=$(gum spin --spinner dot --title "Deleting Device (ID-${device_id_delete})..." --show-output -- curl -L -H "application/json" -d '' "${gapps_url}?action=delete&table=Device&id=${device_id_delete}")
        echo "${delete_feedback}" | jq
    fi
}

function task_select_device_pcsync() {
    filter_header="$1"
    existing_value="$2"
    filtered_device_string=$(escapejc "$(echo -e ${all_device_string} | gum filter --indicator=">" --header="${filter_header}: ID | Device Name | Device Type | IP Address | SSH User | SSH Port" --value="${existing_value}")")
    # filtered_device_string=$(echo -e ${all_device_string} | gum choose --header="$1")
    filtered_device_array=(${filtered_device_string})
    filtered_id=${filtered_device_array[0]}
    echo ${all_device_array["${filtered_id},id"]}
}

function task_view_pcsync() {
    filtered_id=$1
    task_id_get=${all_task_array["${filtered_id},id"]}
    task_type_get=${all_task_array["${filtered_id},task_type"]}
    use_program_get=${all_task_array["${filtered_id},use_program"]}
    program_duty_get=${all_task_array["${filtered_id},program_duty"]}
    cmd_argument_get=${all_task_array["${filtered_id},cmd_argument"]}
    working_device_get=${all_task_array["${filtered_id},working_device"]}
    pwd_path_get=${all_task_array["${filtered_id},pwd_path"]}
    transfer_from_get=${all_task_array["${filtered_id},transfer_from"]}
    transfer_to_get=${all_task_array["${filtered_id},transfer_to"]}
    from_path_get=${all_task_array["${filtered_id},from_path"]}
    to_path_get=${all_task_array["${filtered_id},to_path"]}
    flip_path_get=${all_task_array["${filtered_id},flip_path"]}
    rclone_name_get=${all_task_array["${filtered_id},rclone_name"]}
    last_run_get=${all_task_array["${filtered_id},last_run"]}
    working_device_dname=${all_device_array["${working_device_get},device_name"]}
    transfer_from_dname=${all_device_array["${transfer_from_get},device_name"]}
    transfer_to_dname=${all_device_array["${transfer_to_get},device_name"]}
    echo "Task Details ->"
    task_show="KEY\tVALUE\n"
    task_show+="ID\t${task_id_get}\n"
    task_show+="Task Type\t${task_type_get}\n"
    task_show+="Use Program\t${use_program_get}\n"
    task_show+="Program Duty\t${program_duty_get}\n"
    task_show+="Command Argument\t${cmd_argument_get}\n"
    task_show+="Working Device\t${working_device_dname}\n"
    task_show+="PWD Path\t${pwd_path_get}\n"
    task_show+="Transfer From\t${transfer_from_dname}\n"
    task_show+="Transfer To\t${transfer_to_dname}\n"
    task_show+="From Path\t${from_path_get}\n"
    task_show+="To Path\t${to_path_get}\n"
    task_show+="Flip Path\t${flip_path_get}\n"
    task_show+="Rclone Name\t${rclone_name_get}\n"
    task_show+="Last Run\t${last_run_get}"
    printf "${task_show}" | prettytable 2
}

function task_view_filterby_list_pcsync() {
    store_device_pcsync
    store_task_pcsync
    filtered_task_string=$(echo -e ${all_task_string} | gum filter --indicator=">" --header="Task List: ID | Task Type | Use Program | Program Duty | Device ID | Transfer From | Transter To")
    filtered_task_array=(${filtered_task_string})
    filtered_id=${filtered_task_array[0]}
    task_view_pcsync ${filtered_id}
}

function task_view_filterby_range_pcsync() {
    store_device_pcsync
    store_task_pcsync
    from_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select From Device: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    from_device_array=(${from_device_string})
    from_device=${from_device_array[0]}
    to_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select To Device: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    to_device_array=(${to_device_string})
    to_device=${to_device_array[0]}

    task_coll_string=""
    for each_id in "${TASK_ID_COLL[@]}"; do
        task_id=${all_task_array["${each_id},id"]}
        task_type=${all_task_array["${each_id},task_type"]}
        use_program=${all_task_array["${each_id},use_program"]}
        program_duty=${all_task_array["${each_id},program_duty"]}
        cmd_argument=${all_task_array["${each_id},cmd_argument"]}
        working_device=${all_task_array["${each_id},working_device"]}
        pwd_path=${all_task_array["${each_id},pwd_path"]}
        transfer_from=${all_task_array["${each_id},transfer_from"]}
        transfer_to=${all_task_array["${each_id},transfer_to"]}
        from_path=${all_task_array["${each_id},from_path"]}
        to_path=${all_task_array["${each_id},to_path"]}
        rclone_name=${all_task_array["${each_id},rclone_name"]}
        last_run=${all_task_array["${each_id},last_run"]}
        working_device_dname=${all_device_array["${working_device},device_name"]}
        transfer_from_dname=${all_device_array["${transfer_from},device_name"]}
        transfer_to_dname=${all_device_array["${transfer_to},device_name"]}

        if [[ ( ${from_device} == ${working_device} && ${to_device} == ${working_device} && ${transfer_from} == 0 && ${transfer_to} == 0 ) || ( ${from_device} == ${working_device} && ${to_device} == ${working_device} && ${transfer_from} == ${working_device} && ${transfer_to} == ${working_device} ) || ( ${from_device} == ${transfer_from} && ${to_device} == ${transfer_to} ) || ( ${from_device} == ${transfer_to} && ${to_device} == ${transfer_from} ) ]]
        then
            task_coll_string+="${task_id}\t${task_type}\t${use_program}\t${program_duty}\t${working_device_dname}\t${transfer_from_dname}\t${transfer_to_dname}\n"
        fi
    done
    task_coll_string=${task_coll_string%??}
    filtered_task_string=$(echo -e ${task_coll_string} | gum filter --indicator=">" --header="Task View: ID | Task Type | Use Program | Program Duty | Device ID | Transfer From | Transter To")
    filtered_task_array=(${filtered_task_string})
    filtered_id=${filtered_task_array[0]}
    task_view_pcsync ${filtered_id}
}

function task_add_pcsync() {
    store_device_pcsync
    rclone_name=""
    echo "Add Task ->"
    task_type=$(escapejc "$(gum choose --header="Select Task Type" "temporary" "regular")")
    working_device=$(escapejc "$(task_select_device_pcsync "Select Working Device" "")")
    use_program=$(escapejc "$(echo -e "git\nrclone\nrsync\nunison\nbsync\ncp\nmv\nmkdir\ntouch\nrm" | gum filter --header="Use Program for Task" --indicator=">")")
    case ${use_program} in
        "git")
            program_duty=$(escapejc "$(gum choose --header="Select Program Duty" "fetch" "pull" "push" "clone")")
            if [[ ${program_duty} == 'clone' ]]
            then
                cmd_argument=$(escapejc "$(gum input --header="Enter Git URL" --placeholder="Write Git URL")")
            else
                cmd_argument=""
            fi
            pwd_path=$(escapejc "$(gum input --header="Enter PWD Path" --placeholder="Write PWD Path")")
            transfer_from=0
            from_path=""
            transfer_to=0
            to_path=""
            ;;
        "rclone")
            program_duty=$(escapejc "$(gum choose --header="Select Program Duty" "sync" "bisync")")
            rclone_name=$(escapejc "$(rclone listremotes | gum choose --header="Select Rclone Remote")")
            cmd_argument=""
            pwd_path=""
            transfer_from=0
            from_path=$(escapejc "$(gum input --header="Enter Sync From Path" --placeholder="Write Sync From Path")")
            transfer_to=0
            to_path=$(escapejc "$(gum input --header="Enter Sync To Path" --placeholder="Write Sync To Path" --value="/sync")")
            ;;
        "rsync")
            program_duty="sync"
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Sync From Device" "")")
            from_path=$(escapejc "$(gum input --header="Enter Transfer From Path" --placeholder="Write Transfer From Path")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Sync To Device" "")")
            to_path=$(escapejc "$(gum input --header="Enter Transfer To Path" --placeholder="Write Transfer To Path")")
            ;;
        "unison")
            program_duty="sync"
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Sync From Device" "")")
            from_path=$(escapejc "$(gum input --header="Enter Sync From Path" --placeholder="Write Sync From Path")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Sync To Device" "")")
            to_path=$(escapejc "$(gum input --header="Enter Sync To Path" --placeholder="Write Sync To Path")")
            ;;
        "bsync")
            program_duty="sync"
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Sync From Device" "")")
            from_path=$(escapejc "$(gum input --header="Enter Sync From Path" --placeholder="Write Sync From Path")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Sync To Device" "")")
            to_path=$(escapejc "$(gum input --header="Enter Sync To Path" --placeholder="Write Sync To Path")")
            ;;
        "cp")
            program_duty="copy"
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Copy From Device (Working/Storage)" "")")
            from_path=$(escapejc "$(gum input --header="Enter Copy From Path" --placeholder="Write Copy From Path")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Copy To Device (Working/Storage)" "")")
            to_path=$(escapejc "$(gum input --header="Enter Copy To Path" --placeholder="Write Copy To Path")")
            ;;
        "mv")
            program_duty=$(escapejc "$(gum choose --header="Select Program Duty" "move" "rename")")
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Move From Device (Working/Storage)" "")")
            from_path=$(escapejc "$(gum input --header="Enter Move From Path" --placeholder="Write Move From Path")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Move To Device (Working/Storage)" "")")
            to_path=$(escapejc "$(gum input --header="Enter Move To Path" --placeholder="Write Move To Path")")
            ;;
        "mkdir")
            program_duty="make_dir"
            cmd_argument=$(escapejc "$(gum input --header="Enter Directory Create Path" --placeholder="Write Directory Create Path")")
            pwd_path=""
            transfer_from=0
            from_path=""
            transfer_to=0
            to_path=""
            ;;
        "touch")
            program_duty="create_file"
            cmd_argument=$(escapejc "$(gum input --header="Enter File Create Path" --placeholder="Write File Create Path")")
            pwd_path=""
            transfer_from=0
            from_path=""
            transfer_to=0
            to_path=""
            ;;
        "rm")
            program_duty="remove"
            cmd_argument=$(escapejc "$(gum input --header="Enter File/Directory Remove Path" --placeholder="Write File/Directory Remove Path")")
            pwd_path=""
            transfer_from=0
            from_path=""
            transfer_to=0
            to_path=""
            ;;
        *)
            program_duty="";;
    esac
    flip_path="no"
    last_run="never"
    # device_ip_address=$(task_device_info_pcsync "${working_device}" "ip_address")
  
    insert_feedback=$(gum spin --spinner dot --title "Adding Task..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"task_type\\\":\\\"${task_type}\\\", \\\"use_program\\\": \\\"${use_program}\\\", \\\"program_duty\\\":\\\"${program_duty}\\\", \\\"cmd_argument\\\":\\\"${cmd_argument}\\\", \\\"working_device\\\":\\\"${working_device}\\\", \\\"pwd_path\\\":\\\"${pwd_path}\\\", \\\"transfer_from\\\":\\\"${transfer_from}\\\", \\\"transfer_to\\\":\\\"${transfer_to}\\\", \\\"from_path\\\":\\\"${from_path}\\\", \\\"to_path\\\":\\\"${to_path}\\\", \\\"flip_path\\\":\\\"${flip_path}\\\", \\\"rclone_name\\\":\\\"${rclone_name}\\\", \\\"last_run\\\":\\\"${last_run}\\\"}\"" "${gapps_url}?action=insert&table=Task")
    echo "${insert_feedback}" | jq
}

function task_edit_pcsync() {
    filtered_id=$1
    task_id_edit=${all_task_array["${filtered_id},id"]}
    task_type_edit=${all_task_array["${filtered_id},task_type"]}
    use_program_edit=${all_task_array["${filtered_id},use_program"]}
    program_duty_edit=${all_task_array["${filtered_id},program_duty"]}
    cmd_argument_edit=$(gum_path "${all_task_array["${filtered_id},cmd_argument"]}")
    working_device_edit=${all_task_array["${filtered_id},working_device"]}
    pwd_path_edit=${all_task_array["${filtered_id},pwd_path"]}
    transfer_from_edit=${all_task_array["${filtered_id},transfer_from"]}
    transfer_to_edit=${all_task_array["${filtered_id},transfer_to"]}
    from_path_edit=$(gum_path "${all_task_array["${filtered_id},from_path"]}")
    to_path_edit=$(gum_path "${all_task_array["${filtered_id},to_path"]}")
    flip_path_edit=${all_task_array["${filtered_id},flip_path"]}
    rclone_name_edit=${all_task_array["${filtered_id},rclone_name"]}
    last_run_edit=${all_task_array["${filtered_id},last_run"]}
    working_device_dname=${all_device_array["${working_device_edit},device_name"]}
    transfer_from_dname=${all_device_array["${transfer_from_edit},device_name"]}
    transfer_to_dname=${all_device_array["${transfer_to_edit},device_name"]}

    echo "Edit Task ->"
    rclone_name=""
    task_type=$(escapejc "$(gum choose --header="Select Task Type" --selected="${task_type_edit}" "temporary" "regular")")
    working_device=$(escapejc "$(task_select_device_pcsync "Select Working Device" "${working_device_dname}")")
    use_program=$(escapejc "$(echo -e "git\nrclone\nrsync\nunison\nbsync\ncp\nmv\nmkdir\ntouch\nrm" | gum filter --header="Use Program for Task" --indicator=">" --value="${use_program_edit}")")
    flip_path="${flip_path_edit}"
    case ${use_program} in
        "git")
            program_duty=$(escapejc "$(gum choose --header="Select Program Duty" --selected="${program_duty_edit}" "fetch" "pull" "push" "clone")")
            if [[ ${program_duty} == 'clone' ]]
            then
                cmd_argument=$(escapejc "$(gum input --header="Enter Git URL" --placeholder="Write Git URL" --value="${cmd_argument_edit}")")
            else
                cmd_argument=""
            fi
            pwd_path=$(escapejc "$(gum input --header="Enter PWD Path" --placeholder="Write PWD Path" --value="${pwd_path_edit}")")
            transfer_from=0
            from_path=""
            transfer_to=0
            to_path=""
            ;;
        "rclone")
            program_duty=$(escapejc "$(gum choose --header="Select Program Duty" --selected="${program_duty_edit}" "sync" "bisync")")
            rclone_name=$(escapejc "$(rclone listremotes | gum choose --header="Select Rclone Remote" --selected="${rclone_name_edit}")")
            cmd_argument=""
            pwd_path=""
            transfer_from=0
            from_path=$(escapejc "$(gum input --header="Enter Sync From Path" --placeholder="Write Sync From Path" --value="${from_path_edit}")")
            transfer_to=0
            to_path=$(escapejc "$(gum input --header="Enter Sync To Path" --placeholder="Write Sync To Path" --value="${to_path_edit}")")
            flip_path=$(escapejc "$(gum choose --header="Select Flip From/To Path" --selected="${flip_path_edit}" "yes" "no")")
            ;;  
        "rsync")
            program_duty="sync"
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Transfer From Device" "${transfer_from_dname}")")
            from_path=$(escapejc "$(gum input --header="Enter Transfer From Path" --placeholder="Write Transfer From Path" --value="${from_path_edit}")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Transfer To Device" "$transfer_to_dname")")
            to_path=$(escapejc "$(gum input --header="Enter Transfer To Path" --placeholder="Write Transfer To Path" --value="${to_path_edit}")")
            ;;
        "unison")
            program_duty="sync"
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Sync From Device" "${transfer_from_dname}")")
            from_path=$(escapejc "$(gum input --header="Enter Sync From Path" --placeholder="Write Sync From Path" --value="${from_path_edit}")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Sync To Device" "$transfer_to_dname")")
            to_path=$(escapejc "$(gum input --header="Enter Sync To Path" --placeholder="Write Sync To Path" --value="${to_path_edit}")")
            ;;
        "bsync")
            program_duty="sync"
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Sync From Device" "${transfer_from_dname}")")
            from_path=$(escapejc "$(gum input --header="Enter Sync From Path" --placeholder="Write Sync From Path" --value="${from_path_edit}")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Sync To Device" "$transfer_to_dname")")
            to_path=$(escapejc "$(gum input --header="Enter Sync To Path" --placeholder="Write Sync To Path" --value="${to_path_edit}")")
            ;;
        "cp")
            program_duty="copy"
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Copy From Device" "${transfer_from_dname}")")
            from_path=$(escapejc "$(gum input --header="Enter Copy From Path" --placeholder="Write Copy From Path" --value="${from_path_edit}")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Copy To Device" "$transfer_to_dname")")
            to_path=$(escapejc "$(gum input --header="Enter Copy To Path" --placeholder="Write Copy To Path" --value="${to_path_edit}")")
            ;;
        "mv")
            program_duty=$(escapejc "$(gum choose --header="Select Program Duty" --selected="${program_duty_edit}" "move" "rename")")
            cmd_argument=""
            pwd_path=""
            transfer_from=$(escapejc "$(task_select_device_pcsync "Select Move From Device" "${transfer_from_dname}")")
            from_path=$(escapejc "$(gum input --header="Enter Move From Path" --placeholder="Write Move From Path" --value="${from_path_edit}")")
            transfer_to=$(escapejc "$(task_select_device_pcsync "Select Move To Device" "$transfer_to_dname")")
            to_path=$(escapejc "$(gum input --header="Enter Move To Path" --placeholder="Write Move To Path" --value="${to_path_edit}")")
            ;;
        "mkdir")
            program_duty="make_dir"
            cmd_argument=$(escapejc "$(gum input --header="Enter Directory Create Path" --placeholder="Write Directory Create Path" --value="${cmd_argument_edit}")")
            pwd_path=""
            transfer_from=0
            from_path=""
            transfer_to=0
            to_path=""
            ;;
        "touch")
            program_duty="create_file"
            cmd_argument=$(escapejc "$(gum input --header="Enter File Create Path" --placeholder="Write File Create Path" --value="${cmd_argument_edit}")")
            pwd_path=""
            transfer_from=0
            from_path=""
            transfer_to=0
            to_path=""
            ;;
        "rm")
            program_duty="remove"
            cmd_argument=$(escapejc "$(gum input --header="Enter File/Directory Remove Path" --placeholder="Write File/Directory Remove Path" --value="${cmd_argument_edit}")")
            pwd_path=""
            transfer_from=0
            from_path=""
            transfer_to=0
            to_path=""
            ;;
        *)
            program_duty="";;
    esac
    last_run="${last_run_edit}"
    # device_ip_address=$(task_device_info_pcsync "${working_device}" "ip_address")
  
    update_feedback=$(gum spin --spinner dot --title "Updating Task (ID-${task_id_edit})..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"task_type\\\":\\\"${task_type}\\\", \\\"use_program\\\": \\\"${use_program}\\\", \\\"program_duty\\\":\\\"${program_duty}\\\", \\\"cmd_argument\\\":\\\"${cmd_argument}\\\", \\\"working_device\\\":\\\"${working_device}\\\", \\\"pwd_path\\\":\\\"${pwd_path}\\\", \\\"transfer_from\\\":\\\"${transfer_from}\\\", \\\"transfer_to\\\":\\\"${transfer_to}\\\", \\\"from_path\\\":\\\"${from_path}\\\", \\\"to_path\\\":\\\"${to_path}\\\", \\\"flip_path\\\":\\\"${flip_path}\\\", \\\"rclone_name\\\":\\\"${rclone_name}\\\", \\\"last_run\\\":\\\"${last_run}\\\"}\"" "${gapps_url}?action=update&table=Task&id=${task_id_edit}")
    echo "${update_feedback}" | jq
}

function task_edit_filterby_list_pcsync() {
    store_device_pcsync
    store_task_pcsync
    filtered_task_string=$(echo -e ${all_task_string} | gum filter --indicator=">" --header="Task Edit: ID | Type | Use Program | Program Duty | Working Device | Transfer From | Transter To")
    filtered_task_array=(${filtered_task_string})
    filtered_id=${filtered_task_array[0]}
    task_edit_pcsync ${filtered_id}
}

function task_edit_filterby_range_pcsync() {
    store_device_pcsync
    store_task_pcsync
    from_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select From Device: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    from_device_array=(${from_device_string})
    from_device=${from_device_array[0]}
    to_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select To Device: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    to_device_array=(${to_device_string})
    to_device=${to_device_array[0]}

    task_coll_string=""
    for each_id in "${TASK_ID_COLL[@]}"; do
        task_id=${all_task_array["${each_id},id"]}
        task_type=${all_task_array["${each_id},task_type"]}
        use_program=${all_task_array["${each_id},use_program"]}
        program_duty=${all_task_array["${each_id},program_duty"]}
        cmd_argument=${all_task_array["${each_id},cmd_argument"]}
        working_device=${all_task_array["${each_id},working_device"]}
        pwd_path=${all_task_array["${each_id},pwd_path"]}
        transfer_from=${all_task_array["${each_id},transfer_from"]}
        transfer_to=${all_task_array["${each_id},transfer_to"]}
        from_path=${all_task_array["${each_id},from_path"]}
        to_path=${all_task_array["${each_id},to_path"]}
        rclone_name=${all_task_array["${each_id},rclone_name"]}
        last_run=${all_task_array["${each_id},last_run"]}
        working_device_dname=${all_device_array["${working_device},device_name"]}
        transfer_from_dname=${all_device_array["${transfer_from},device_name"]}
        transfer_to_dname=${all_device_array["${transfer_to},device_name"]}

        if [[ ( ${from_device} == ${working_device} && ${to_device} == ${working_device} && ${transfer_from} == 0 && ${transfer_to} == 0 ) || ( ${from_device} == ${working_device} && ${to_device} == ${working_device} && ${transfer_from} == ${working_device} && ${transfer_to} == ${working_device} ) || ( ${from_device} == ${transfer_from} && ${to_device} == ${transfer_to} ) || ( ${from_device} == ${transfer_to} && ${to_device} == ${transfer_from} ) ]]
        then
            task_coll_string+="${task_id}\t${task_type}\t${use_program}\t${program_duty}\t${working_device_dname}\t${transfer_from_dname}\t${transfer_to_dname}\n"
        fi
    done
    task_coll_string=${task_coll_string%??}
    filtered_task_string=$(echo -e ${task_coll_string} | gum filter --indicator=">" --header="Task Edit: ID | Type | Use Program | Program Duty | Working Device | Transfer From | Transter To")
    filtered_task_array=(${filtered_task_string})
    filtered_id=${filtered_task_array[0]}
    task_edit_pcsync ${filtered_id}
}

function task_delete_pcsync() {
    filtered_id=$1
    task_id_delete=${all_task_array["${filtered_id},id"]}
    task_type_delete=${all_task_array["${filtered_id},task_type"]}
    use_program_delete=${all_task_array["${filtered_id},use_program"]}
    program_duty_delete=${all_task_array["${filtered_id},program_duty"]}
    cmd_argument_delete=${all_task_array["${filtered_id},cmd_argument"]}
    working_device_delete=${all_task_array["${filtered_id},working_device"]}
    pwd_path_delete=${all_task_array["${filtered_id},pwd_path"]}
    transfer_from_delete=${all_task_array["${filtered_id},transfer_from"]}
    transfer_to_delete=${all_task_array["${filtered_id},transfer_to"]}
    from_path_delete=${all_task_array["${filtered_id},from_path"]}
    to_path_delete=${all_task_array["${filtered_id},to_path"]}
    flip_path_delete=${all_task_array["${filtered_id},flip_path"]}
    rclone_name_delete=${all_task_array["${filtered_id},rclone_name"]}
    last_run_delete=${all_task_array["${filtered_id},last_run"]}
    working_device_dname=${all_device_array["${working_device_delete},device_name"]}
    transfer_from_dname=${all_device_array["${transfer_from_delete},device_name"]}
    transfer_to_dname=${all_device_array["${transfer_to_delete},device_name"]}
    echo "Delete Task ->"
    task_show="  KEY\tVALUE\n"
    task_show+="  ID\t${task_id_delete}\n"
    task_show+="  Task Type\t${task_type_delete}\n"
    task_show+="  Use Program\t${use_program_delete}\n"
    task_show+="  Program Duty\t${program_duty_delete}\n"
    task_show+="  Command Argument\t${cmd_argument_delete}\n"
    task_show+="  Working Device\t${working_device_dname}\n"
    task_show+="  PWD Path\t${pwd_path_delete}\n"
    task_show+="  Transfer From\t${transfer_from_dname}\n"
    task_show+="  Transfer To\t${transfer_to_dname}\n"
    task_show+="  From Path\t${from_path_delete}\n"
    task_show+="  To Path\t${to_path_delete}\n"
    task_show+="  Flip Path\t${flip_path_delete}\n"
    task_show+="  Rclone Name\t${rclone_name_get}\n"
    task_show+="  Last Run\t${last_run_delete}"
    printf "${task_show}" | prettytable 2

    confirm_delete=$(gum confirm --default="No" "Delete This Task?" && echo "yes" || echo "no")
    if [[ ${confirm_delete} == 'yes' ]]
    then
        delete_feedback=$(gum spin --spinner dot --title "Deleting Task (ID-${task_id_delete})..." --show-output -- curl -L -H "application/json" -d '' "${gapps_url}?action=delete&table=Task&id=${task_id_delete}")
        echo "${delete_feedback}" | jq
    fi
}

function task_delete_filterby_list_pcsync() {
    store_device_pcsync
    store_task_pcsync
    filtered_task_string=$(echo -e ${all_task_string} | gum filter --indicator=">" --header="Task Delete: ID | Task Type | Use Program | Program Duty | Device ID | Transfer From | Transter To")
    filtered_task_array=(${filtered_task_string})
    filtered_id=${filtered_task_array[0]}
    task_delete_pcsync ${filtered_id}
}

function task_delete_filterby_range_pcsync() {
    store_device_pcsync
    store_task_pcsync
    from_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select From Device: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    from_device_array=(${from_device_string})
    from_device=${from_device_array[0]}
    to_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select To Device: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    to_device_array=(${to_device_string})
    to_device=${to_device_array[0]}

    task_coll_string=""
    for each_id in "${TASK_ID_COLL[@]}"; do
        task_id=${all_task_array["${each_id},id"]}
        task_type=${all_task_array["${each_id},task_type"]}
        use_program=${all_task_array["${each_id},use_program"]}
        program_duty=${all_task_array["${each_id},program_duty"]}
        cmd_argument=${all_task_array["${each_id},cmd_argument"]}
        working_device=${all_task_array["${each_id},working_device"]}
        pwd_path=${all_task_array["${each_id},pwd_path"]}
        transfer_from=${all_task_array["${each_id},transfer_from"]}
        transfer_to=${all_task_array["${each_id},transfer_to"]}
        from_path=${all_task_array["${each_id},from_path"]}
        to_path=${all_task_array["${each_id},to_path"]}
        rclone_name=${all_task_array["${each_id},rclone_name"]}
        last_run=${all_task_array["${each_id},last_run"]}
        working_device_dname=${all_device_array["${working_device},device_name"]}
        transfer_from_dname=${all_device_array["${transfer_from},device_name"]}
        transfer_to_dname=${all_device_array["${transfer_to},device_name"]}

        if [[ ( ${from_device} == ${working_device} && ${to_device} == ${working_device} && ${transfer_from} == 0 && ${transfer_to} == 0 ) || ( ${from_device} == ${working_device} && ${to_device} == ${working_device} && ${transfer_from} == ${working_device} && ${transfer_to} == ${working_device} ) || ( ${from_device} == ${transfer_from} && ${to_device} == ${transfer_to} ) || ( ${from_device} == ${transfer_to} && ${to_device} == ${transfer_from} ) ]]
        then
            task_coll_string+="${task_id}\t${task_type}\t${use_program}\t${program_duty}\t${working_device_dname}\t${transfer_from_dname}\t${transfer_to_dname}\n"
        fi
    done
    task_coll_string=${task_coll_string%??}
    filtered_task_string=$(echo -e ${task_coll_string} | gum filter --indicator=">" --header="Task Delete: ID | Task Type | Use Program | Program Duty | Device ID | Transfer From | Transter To")
    filtered_task_array=(${filtered_task_string})
    filtered_id=${filtered_task_array[0]}
    task_delete_pcsync ${filtered_id}
}

function device_task_download_pcsync() {
    if [[ ${get_device_store} == "" ]]
    then
        if [[ "$OSTYPE" == 'msys' ]]
        then
            echo "Fetching Device List..."
            get_device_list=$(curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Device")
        else
            get_device_list=$(gum spin --spinner dot --title "Fetching Device List..." --show-output -- curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Device")
        fi
    else
        get_device_list="${get_device_store}"
    fi
    
    if [[ ${get_task_store} == "" ]]
    then
        if [[ "$OSTYPE" == 'msys' ]]
        then
            echo "Fetching Task List..."
            get_task_list=$(curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Task")
        else
            get_task_list=$(gum spin --spinner dot --title "Fetching Task List..." --show-output -- curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=Task")
        fi 
    else
        get_task_list="${get_task_store}"
    fi
    
    echo "${get_device_list}" | jq '.data' > "${device_list_file}"
    echo "${get_task_list}" | jq '.data' > "${task_list_file}"
    echo "Device And Task List Downloaded."
}

function task_run_pcsync() {
    declare -a ID_TASK
    declare -A run_date_array
    declare -A all_device_coll
    declare -A taskc_array  # Selected "Task Collection Array"
    all_device_string_hdd=""
    this_device_id=""
    run_type="$1"
    run_source="$2"
    run_env='linux'
    
    if [[ ( ${run_source} == 'hdd' ) && ( ! -f "${device_list_file}" || ! -f "${task_list_file}" ) ]]; then
        device_task_download_pcsync
    fi

    if [[ ${run_source} == 'hdd' ]]
    then
        get_device_array=$(escape_single_quote "$(cat "${device_list_file}")" | jq -r 'map("
all_device_array['\''\(.id),id'\'']='\''\(.id)'\'';
all_device_array['\''\(.id),device_name'\'']='\''\(.device_name)'\'';
all_device_array['\''\(.id),device_type'\'']='\''\(.device_type)'\'';
all_device_array['\''\(.id),ip_address'\'']='\''\(.ip_address)'\'';
all_device_array['\''\(.id),ssh_user'\'']='\''\(.ssh_user)'\'';
all_device_array['\''\(.id),ssh_port'\'']='\''\(.ssh_port)'\'';
all_device_array['\''\(.id),base_path'\'']='\''\(.base_path)'\'';
DEVICE_ID_COLL+=('\''\(.id)'\'');
all_device_string+=\"\(.id)\\t\(.device_name)\\t\(.device_type)\\t\(.ip_address)\\t\(.ssh_user)\\t\(.ssh_port)\\n\";
")|.[]')
        eval "${get_device_array}"

        get_task_array=$(escape_single_quote "$(cat "${task_list_file}")" | jq -r 'map("
all_task_array['\''\(.id),id'\'']='\''\(.id)'\'';
all_task_array['\''\(.id),task_type'\'']='\''\(.task_type)'\'';
all_task_array['\''\(.id),use_program'\'']='\''\(.use_program)'\'';
all_task_array['\''\(.id),program_duty'\'']='\''\(.program_duty)'\'';
all_task_array['\''\(.id),cmd_argument'\'']='\''\(.cmd_argument)'\'';
all_task_array['\''\(.id),working_device'\'']='\''\(.working_device)'\'';
all_task_array['\''\(.id),pwd_path'\'']='\''\(.pwd_path)'\'';
all_task_array['\''\(.id),transfer_from'\'']='\''\(.transfer_from)'\'';
all_task_array['\''\(.id),transfer_to'\'']='\''\(.transfer_to)'\'';
all_task_array['\''\(.id),from_path'\'']='\''\(.from_path)'\'';
all_task_array['\''\(.id),to_path'\'']='\''\(.to_path)'\'';
all_task_array['\''\(.id),flip_path'\'']='\''\(.flip_path)'\'';
all_task_array['\''\(.id),rclone_name'\'']='\''\(.rclone_name)'\'';
all_task_array['\''\(.id),last_run'\'']='\''\(.last_run)'\'';
TASK_ID_COLL+=('\''\(.id)'\'');
all_task_string+=\"\(.id)\\t\(.task_type)\\t\(.use_program)\\t\(.program_duty)\\t${all_device_array['\''\(.working_device),device_name'\'']}\\t${all_device_array['\''\(.transfer_from),device_name'\'']}\\t${all_device_array['\''\(.transfer_to),device_name'\'']}\\n\";
")|.[]')
        eval "${get_task_array}"
    else
        store_device_pcsync
        store_task_pcsync
    fi

    for each_id in "${DEVICE_ID_COLL[@]}"; do
        if [[ ${all_device_array["${each_id},ip_address"]} == "${this_device_ip}" ]]
        then
            this_device_id=${all_device_array["${each_id},id"]}
        fi
    done
    all_device_string=${all_device_string%??}

    from_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select From Device: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    from_device_array=(${from_device_string})
    from_device=${from_device_array[0]}
    to_device_string=$(echo -e ${all_device_string} | gum filter --indicator=">" --header="Select To Device: ID | Device Name | Device Type | IP Address | SSH User | SSH Port")
    to_device_array=(${to_device_string})
    to_device=${to_device_array[0]}

    if [[ ${this_device_id} == ${from_device} ]]
    then
        from_device_os="$OSTYPE"
    else
        from_device_ip=${all_device_array["${from_device},ip_address"]}
        from_device_user=${all_device_array["${from_device},ssh_user"]}
        from_device_port=${all_device_array["${from_device},ssh_port"]}
        from_device_type=${all_device_array["${from_device},device_type"]}
        if [[ ${from_device_type} != 'storage' ]]
        then
            from_device_os=$(ssh -p ${from_device_port} ${from_device_user}@${from_device_ip} "bash -c '"'echo $OSTYPE'"'")
            all_device_array["${from_device},os_type"]=${from_device_os}
        fi
    fi
    if [[ ${this_device_id} == ${to_device} ]]
    then
        to_device_os="$OSTYPE"
    else
        to_device_ip=${all_device_array["${to_device},ip_address"]}
        to_device_user=${all_device_array["${to_device},ssh_user"]}
        to_device_port=${all_device_array["${to_device},ssh_port"]}
        to_device_type=${all_device_array["${to_device},device_type"]}
        if [[ ${to_device_type} != 'storage' ]]
        then
            to_device_os=$(ssh -p ${to_device_port} ${to_device_user}@${to_device_ip} "bash -c '"'echo $OSTYPE'"'")
            all_device_array["${to_device},os_type"]=${to_device_os}
        fi
    fi
    if [[ ((${this_device_id} != ${from_device}) || (${OSTYPE} == 'msys')) && ((${this_device_id} != ${to_device}) || (${OSTYPE} == 'msys')) && ((${from_device_os} == 'msys') || (${to_device_os} == 'msys')) ]] # Windows-OS
    then
        run_env=$(gum choose --header="Select Windows-OS Command Run Environment" "bash-windows" "wsl")
    fi
    
    for each_id in "${TASK_ID_COLL[@]}"; do
        task_id=${all_task_array["${each_id},id"]}
        task_type=${all_task_array["${each_id},task_type"]}
        use_program=${all_task_array["${each_id},use_program"]}
        program_duty=${all_task_array["${each_id},program_duty"]}
        cmd_argument=${all_task_array["${each_id},cmd_argument"]}
        working_device=${all_task_array["${each_id},working_device"]}
        pwd_path=${all_task_array["${each_id},pwd_path"]}
        transfer_from=${all_task_array["${each_id},transfer_from"]}
        transfer_to=${all_task_array["${each_id},transfer_to"]}
        from_path=${all_task_array["${each_id},from_path"]}
        to_path=${all_task_array["${each_id},to_path"]}
        flip_path=${all_task_array["${each_id},flip_path"]}
        rclone_name=${all_task_array["${each_id},rclone_name"]}
        last_run=${all_task_array["${each_id},last_run"]}

        if [[ (${from_device} == ${working_device} && ${to_device} == ${working_device} && ${transfer_from} == 0 && ${transfer_to} == 0) || (${from_device} == ${working_device} && ${to_device} == ${working_device} && ${transfer_from} == ${working_device} && ${transfer_to} == ${working_device}) || (${from_device} == ${transfer_from} && ${to_device} == ${transfer_to}) || (${from_device} == ${transfer_to} && ${to_device} == ${transfer_from}) ]]
        then
            # echo "Entry"
            ID_TASK+=("${task_id}")
            taskc_array["${task_id},id"]="${task_id}"
            taskc_array["${task_id},task_type"]="${task_type}"
            taskc_array["${task_id},use_program"]="${use_program}"
            taskc_array["${task_id},program_duty"]="${program_duty}"
            taskc_array["${task_id},cmd_argument"]="${cmd_argument}"
            taskc_array["${task_id},working_device"]="${working_device}"
            taskc_array["${task_id},pwd_path"]="${pwd_path}"
            taskc_array["${task_id},transfer_from"]="${transfer_from}"
            taskc_array["${task_id},transfer_to"]="${transfer_to}"
            taskc_array["${task_id},from_path"]="${from_path}"
            taskc_array["${task_id},to_path"]="${to_path}"
            taskc_array["${task_id},flip_path"]="${flip_path}"
            taskc_array["${task_id},rclone_name"]="${rclone_name}"
            taskc_array["${task_id},last_run"]="${last_run}"

            working_device_type=${all_device_array["${working_device},device_type"]}
            transfer_from_type=${all_device_array["${transfer_from},device_type"]}
            transfer_to_type=${all_device_array["${transfer_to},device_type"]}
            if [[ (${working_device} != ${this_device_id}) && (${working_device_type} != 'storage') ]]
            then
                is_remote_device='yes'
                ip_address_remote=${all_device_array["${working_device},ip_address"]}
                ssh_user_remote=${all_device_array["${working_device},ssh_user"]}
                ssh_port_remote=${all_device_array["${working_device},ssh_port"]}
                remote_os=${all_device_array["${working_device},os_type"]}
                if [[ (${run_env} == 'bash-windows') && (${remote_os} == 'msys') ]]
                then
                    command="ssh -t -p ${ssh_port_remote} ${ssh_user_remote}@${ip_address_remote} \"bash -c '\"'"
                elif [[ (${run_env} == "wsl") && (${remote_os} == 'msys') ]]
                then
                    command="ssh -t -p ${ssh_port_remote} ${ssh_user_remote}@${ip_address_remote} \"wsl -e bash -c \\\""
                else
                    command="ssh -t -p ${ssh_port_remote} ${ssh_user_remote}@${ip_address_remote} \""
                fi
            else
                is_remote_device='no'
                if [[ "${run_env}" == "wsl" ]]
                then
                    command="wsl -e bash -c \""
                else
                    command=""
                fi
            fi
            ip_address_dest=${all_device_array["${transfer_to},ip_address"]}
            ssh_user_dest=${all_device_array["${transfer_to},ssh_user"]}
            ssh_port_dest=${all_device_array["${transfer_to},ssh_port"]}
            base_path_dest=${all_device_array["${transfer_to},base_path"]}

            # If PC is Linux, then change direction from Windows->Linux to Linux->Windows and so on.
            if [[ (${is_remote_device} == 'no') && (${OSTYPE} != 'msys') && (${from_device_os} == 'msys') && (${to_device_os} != 'msys') && (${from_device_os} != '') && (${to_device_os} != '')]]
            then
                from_device_os='linux-gnu'
                to_device_os='msys'
            fi
            if [[ (${is_remote_device} == 'yes') && (${remote_os} != 'msys') && (${from_device_os} == 'msys') && (${to_device_os} != 'msys') && (${from_device_os} != '') && (${to_device_os} != '')]]
            then
                from_device_os='linux-gnu'
                to_device_os='msys'
            fi
            if [[ (${is_remote_device} == 'no') && (${OSTYPE} == 'msys') && (${from_device_os} != 'msys') && (${to_device_os} == 'msys') && (${from_device_os} != '') && (${to_device_os} != '')]]
            then
                from_device_os='msys'
                to_device_os='linux-gnu'
            fi
            if [[ (${is_remote_device} == 'yes') && (${remote_os} == 'msys') && (${from_device_os} != 'msys') && (${to_device_os} == 'msys') && (${from_device_os} != '') && (${to_device_os} != '') ]]
            then
                from_device_os='msys'
                to_device_os='linux-gnu'
            fi
            
            case ${use_program} in
                "git")
                    case ${program_duty} in
                        "fetch")
                            # echo "git fetch"
                            if [[ ("${is_remote_device}" == 'yes') && ("${run_env}" == 'linux') ]]
                            then
                                command+="export GPG_TTY=$(tty) && cd '${pwd_path}' && git fetch"
                            elif [[ ("${is_remote_device}" == 'yes') && ("${run_env}" == 'bash-windows') ]]
                            then
                                command+="export GPG_TTY=$(tty); cd \"'\"${pwd_path}\"'\"; git fetch"
                            else
                                command+="cd '${pwd_path}' && git fetch"
                            fi
                            ;;
                        "pull")
                            # echo "git pull"
                            if [[ ("${is_remote_device}" == 'yes') && ("${run_env}" == 'linux') ]]
                            then
                                command+="export GPG_TTY=$(tty) && cd '${pwd_path}' && git pull"
                            elif [[ ("${is_remote_device}" == 'yes') && ("${run_env}" == 'bash-windows') ]]
                            then
                                command+="export GPG_TTY=$(tty); cd \"'\"${pwd_path}\"'\"; git pull"
                            else
                                command+="cd '${pwd_path}' && git pull"
                            fi
                            ;;
                        "push")
                            # echo "git push"
                            if [[ ("${is_remote_device}" == 'yes') && ("${run_env}" == 'linux') ]]
                            then
                                command+="export GPG_TTY=$(tty) && cd '${pwd_path}' && git push"
                            elif [[ ("${is_remote_device}" == 'yes') && ("${run_env}" == 'bash-windows') ]]
                            then
                                command+="export GPG_TTY=$(tty); cd \"'\"${pwd_path}\"'\"; git push"
                            else
                                command+="cd '${pwd_path}' && git push"
                            fi
                            ;;
                        "clone")
                            # echo "git clone"
                            if [[ ("${is_remote_device}" == 'yes') && ("${run_env}" == 'linux') ]]
                            then
                                command+="export GPG_TTY=$(tty) && cd '${pwd_path}' && git clone ${cmd_argument}"
                            elif [[ ("${is_remote_device}" == 'yes') && ("${run_env}" == 'bash-windows') ]]
                            then
                                command+="export GPG_TTY=$(tty); cd \"'\"${pwd_path}\"'\"; git clone ${cmd_argument}"
                            else
                                command+="cd '${pwd_path}' && git clone ${cmd_argument}"
                            fi
                            ;;
                    esac;;
                "rclone")
                    if [[ ${flip_path} == 'yes' ]]
                    then
                        from_path_rclone="${rclone_name}'${to_path}'"
                        to_path_rclone="'${from_path}'"
                    else
                        from_path_rclone="'${from_path}'"
                        to_path_rclone="${rclone_name}'${to_path}'"
                    fi
                    case ${program_duty} in
                        "sync")
                            if [[ ${run_type} == 'dry-run' ]]
                            then
                                command+="rclone sync --dry-run -v -v ${from_path_rclone} ${to_path_rclone}"
                            else
                                command+="rclone sync --progress ${from_path_rclone} ${to_path_rclone}"
                            fi
                            ;;
                        "bisync")
                            # echo "rclone sync"
                            if [[ ${run_type} == 'dry-run' ]]
                            then
                                command+="rclone bisync --dry-run -v -v ${from_path_rclone} ${to_path_rclone}"
                            else
                                # Do not use "--interactive" with "--verbose", because prompt overwrites with progress
                                command+="rclone bisync --interactive ${from_path_rclone} ${to_path_rclone}"
                            fi
                            ;;
                    esac;;
                "rsync")
                    case ${program_duty} in
                        "sync")
                            # echo "rsync transfer"
                            if [[ (${transfer_from_type} == 'storage') || (${transfer_to_type} == 'storage') || (${ip_address_remote} == ${ip_address_dest}) || ((${is_remote_device} == 'no') && (${this_device_ip} == ${ip_address_dest})) ]]
                            then
                                command+="rsync -rvz --progress '${from_path}' '${to_path}'"
                            elif [[ ((${from_device_os} != 'msys') && (${to_device_os} == 'msys')) || ((${from_device_os} == 'msys') && (${to_device_os} == 'msys')) ]]
                            then
                                command+="rsync -rvz -e 'ssh -p ${ssh_port_dest}' --rsync-path='C:\ProgramData\scoop\apps\git\current\usr\bin\rsync.exe' --progress '${from_path}' ${ssh_user_dest}@${ip_address_dest}:'${base_path_dest}${to_path}'"
                            else
                                command+="rsync -rvz -e 'ssh -p ${ssh_port_dest}' --progress '${from_path}' ${ssh_user_dest}@${ip_address_dest}:'${base_path_dest}${to_path}'"
                            fi
                            ;;
                    esac;;
                "unison")
                    case ${program_duty} in
                        "sync")
                            # Unix to Windows path conversion, based on operating system
                            if [[ (${run_env} == 'bash-windows') && (${is_remote_device} == 'no') ]]
                            then
                                if [[ (${from_device_os} == 'msys') || ((${OSTYPE} == 'msys') && (${from_device_type} == 'storage')) ]]
                                then
                                    from_path="$(unix2win_path "${from_path}")"
                                fi
                                if [[ (${to_device_os} == 'msys') || ((${OSTYPE} == 'msys') && (${to_device_type} == 'storage')) ]]
                                then
                                    to_path="$(unix2win_path "${to_path}")"
                                fi
                            elif [[ (${run_env} == 'bash-windows') && (${is_remote_device} == 'yes') ]]
                            then
                                if [[ (${from_device_os} == 'msys') || ((${remote_os} == 'msys') && (${from_device_type} == 'storage')) ]]
                                then
                                    from_path="$(unix2win_path "${from_path}")"
                                fi
                                if [[ (${to_device_os} == 'msys') || (${remote_os} != 'msys') || ((${remote_os} == 'msys') && (${to_device_type} == 'storage')) ]]
                                then
                                    to_path="$(unix2win_path "${to_path}")"
                                fi
                            elif [[ (${run_env} == 'wsl') && (${is_remote_device} == 'no') ]]
                            then
                                if [[ (${from_device_os} == 'msys') ]]
                                then
                                    echo -n ''
                                fi
                                if [[ (${to_device_os} == 'msys') && (${remote_os} == 'msys') ]]
                                then
                                    to_path="$(unix2win_path "${to_path}")"
                                fi
                            elif [[ (${run_env} == 'wsl') && (${is_remote_device} == 'yes') ]]
                            then
                                if [[ (${from_device_os} == 'msys') ]]
                                then
                                    echo -n ''
                                fi
                                if [[ (${to_device_os} == 'msys') && (${ip_address_remote} != ${ip_address_dest}) ]]
                                then
                                    to_path="$(unix2win_path "${to_path}")"
                                fi
                            elif [[ (${run_env} == 'linux') && (${is_remote_device} == 'no') ]]
                            then
                                if [[ (${from_device_os} == 'msys') ]]
                                then
                                    echo -n ''
                                fi
                                if [[ (${to_device_os} == 'msys') ]]
                                then
                                    to_path="$(unix2win_path "${to_path}")"
                                fi
                            elif [[ (${run_env} == 'linux') && (${is_remote_device} == 'yes') ]]
                            then
                                if [[ (${from_device_os} == 'msys') ]]
                                then
                                    from_path="$(unix2win_path "${from_path}")"
                                fi
                                if [[ (${to_device_os} == 'msys') ]]
                                then
                                    echo -n ''
                                fi
                            fi

                            # Hide same PC to same PC/Storage ip address
                            if [[ (${transfer_from_type} == 'storage') || (${transfer_to_type} == 'storage') || ((${is_remote_device} == 'no') && (${this_device_ip} == ${ip_address_dest})) || ((${is_remote_device} == 'yes') && (${ip_address_remote} == ${ip_address_dest})) ]]
                            then
                                command+="unison -fat '${from_path}' '${to_path}'"
                            else
                                command+="unison -fat '${from_path}' ssh://${ssh_user_dest}@${ip_address_dest}:${ssh_port_dest}/'${to_path}'"
                            fi
                            ;;
                    esac;;
                "bsync")
                    case ${program_duty} in
                        "sync")
                            # echo "bsync sync"
                            if [[ "${run_env}" == 'bash-windows' ]]
                            then
                                command+="echo 'Bsync is not supported in Git-Bash (Windows-OS)'"
                            elif [[ ( ${transfer_from_type} == 'storage' ) || ( ${transfer_to_type} == 'storage' ) ]]
                            then
                                command+="bsync -i '${from_path}' '${to_path}'"
                            else
                                command+="bsync -i -p ${ssh_port_dest} '${from_path}'  ${ssh_user_dest}@${ip_address_dest}:'${base_path_dest}${to_path}'"
                            fi
                            ;;
                    esac;;
                "cp")
                    case ${program_duty} in
                        "copy")
                            # echo "cp copy"
                            if [[ "${from_path: -1}" == '/' ]]
                            then
                                from_path_cp=${from_path%?}
                                command+="cp -rv '${from_path_cp}/.' '${to_path}'"
                                
                            elif [[ "${from_path: -2}" == '/.' ]]
                            then
                                from_path_cp=${from_path%??}
                                command+="cp -rv '${from_path_cp}/.' '${to_path}'"
                            else
                                command+="cp -rv '${from_path}' '${to_path}'"
                            fi

                            cp_progress=" & progress -mp"
                            if [[ (${is_remote_device} == 'yes') || (${run_env} == 'wsl') ]]
                            then
                                cp_progress+=" \\\$!"
                            else
                                cp_progress+=" \$!"
                            fi
                            if [[ ${run_env} == 'bash-windows' ]]
                            then
                                cp_progress=""
                            fi
                            command+="${cp_progress}"
                            ;;
                    esac;;
                "mv")
                    case ${program_duty} in
                        "move")
                            # echo "mv move"
                            if [[ "${from_path: -1}" == '/' ]]
                            then
                                from_path_mv=${from_path%?}
                                command+="mv -v '${from_path_mv}'/* '${from_path_mv}'/.* '${to_path}'"
                                
                            elif [[ "${from_path: -2}" == '/*' ]]
                            then
                                from_path_mv=${from_path%??}
                                command+="mv -v '${from_path_mv}'/* '${from_path_mv}'/.* '${to_path}'"
                            else
                                command+="mv '${from_path}' '${to_path}'"
                            fi

                            mv_progress=" & progress -mp"
                            if [[ (${is_remote_device} == 'yes') || ${run_env} == 'wsl' ]]
                            then
                                mv_progress+=" \\\$!"
                            else
                                mv_progress+=" \$!"
                            fi
                            if [[ ${run_env} == 'bash-windows' ]]
                            then
                                mv_progress=""
                            fi
                            command+="${mv_progress}"
                            ;;
                        "rename")
                            command+="mv '${from_path}' '${to_path}'"
                            ;;
                    esac;;
                "mkdir")
                    case ${program_duty} in
                        "make_dir")
                            # echo "mkdir make_dir"
                            command+="mkdir -pv '${cmd_argument}'"
                            ;;
                    esac;;
                "touch")
                    case ${program_duty} in
                        "create_file")
                            # echo "touch create_file"
                            command+="touch '${cmd_argument}'"
                            ;;
                    esac;;
                "rm")
                    case ${program_duty} in
                        "remove")
                            # echo "rm remove_file"
                            command+="rm -rv '${cmd_argument}'"
                            ;;
                    esac;;
            esac
            if [[ (${working_device} != ${this_device_id}) && (${working_device_type} != 'storage') ]] # Remote Device
            then
                if [[ "${run_env}" == 'bash-windows' ]]
                then
                    command+="'\"'\""
                elif [[ "${run_env}" == "wsl" ]]
                then
                    command+="\\\"\""
                else
                    command+="\""
                fi
            else
                if [[ "${run_env}" == "wsl" ]]
                then
                    command+="\""
                else
                    command+=""
                fi
            fi
            taskc_array["${task_id},command"]="${command}"
        fi
    done

    for each_id in "${ID_TASK[@]}"; do
        echo -ne "\033[1;32m(${each_id})\033[0m "
        echo "${taskc_array["${each_id},command"]}"
        echo "   Last Run: "${taskc_array["${each_id},last_run"]}
        if [[ ( ${run_type} != 'cmd-view' ) && ( ${run_type} != 'selective-run' ) ]]
        then
            read -p "Run Command ([y]es/[n]o/[e]xit): " cmd_action
            if [[ ${cmd_action} == 'y' ]]
            then
                eval "${taskc_array["${each_id},command"]}"
                run_date_array[${each_id}]=$(date '+%Y-%m-%d %H:%M:%S')
            elif [[ ${cmd_action} == 'n' ]]
            then
                continue
            elif [[ ${cmd_action} == 'e' ]]
            then
                exit
            fi
        fi
    done

    if [[ ${run_type} == 'selective-run' ]]
    then
        read -p "Enter Task ID to Run: " selected_id
        echo -ne "\033[1;32m>>>\033[0m "
        echo "${taskc_array["${selected_id},command"]}"
        echo "   Last Run: "${taskc_array["${selected_id},last_run"]}
        read -p "Run Command ([y]es/[n]o): " cmd_action_sel
        if [[ ${cmd_action_sel} == 'y' ]]
        then
            eval "${taskc_array["${selected_id},command"]}"
            run_date_array[${selected_id}]=$(date '+%Y-%m-%d %H:%M:%S')
        elif [[ ${cmd_action_sel} == 'n' ]]
        then
            exit
        fi
    fi

    if [[ ( ${run_type} == 'final-run' ) || ( ${run_type} == 'selective-run' ) ]]
    then
        for every_id in "${!run_date_array[@]}"; do
            if [[ ${taskc_array["${every_id},task_type"]} == 'temporary' ]]
            then
                task_id_delete=${all_task_array["${every_id},id"]}
                task_type_delete=${all_task_array["${every_id},task_type"]}
                use_program_delete=${all_task_array["${every_id},use_program"]}
                program_duty_delete=${all_task_array["${every_id},program_duty"]}
                cmd_argument_delete=${all_task_array["${every_id},cmd_argument"]}
                working_device_delete=${all_task_array["${every_id},working_device"]}
                pwd_path_delete=${all_task_array["${every_id},pwd_path"]}
                transfer_from_delete=${all_task_array["${every_id},transfer_from"]}
                transfer_to_delete=${all_task_array["${every_id},transfer_to"]}
                from_path_delete=${all_task_array["${every_id},from_path"]}
                to_path_delete=${all_task_array["${every_id},to_path"]}
                rclone_name_delete=${all_task_array["${every_id},rclone_name"]}
                last_run_delete=${all_task_array["${every_id},last_run"]}
                working_device_dname=${all_device_array["${working_device_delete},device_name"]}
                transfer_from_dname=${all_device_array["${transfer_from_delete},device_name"]}
                transfer_to_dname=${all_device_array["${transfer_to_delete},device_name"]}
                echo "Delete Task ->"
                task_show="  KEY\tVALUE\n"
                task_show+="  ID\t${task_id_delete}\n"
                task_show+="  Task Type\t${task_type_delete}\n"
                task_show+="  Use Program\t${use_program_delete}\n"
                task_show+="  Program Duty\t${program_duty_delete}\n"
                task_show+="  Command Argument\t${cmd_argument_delete}\n"
                task_show+="  Working Device\t${working_device_dname}\n"
                task_show+="  PWD Path\t${pwd_path_delete}\n"
                task_show+="  Transfer From\t${transfer_from_dname}\n"
                task_show+="  Transfer To\t${transfer_to_dname}\n"
                task_show+="  From Path\t${from_path_delete}\n"
                task_show+="  To Path\t${to_path_delete}\n"
                task_show+="  Rclone Name\t${rclone_name_get}\n"
                task_show+="  Last Run\t${last_run_delete}"
                printf "${task_show}" | prettytable 2

                confirm_delete=$(gum confirm --default="No" "Delete This Task?" && echo "yes" || echo "no")
                if [[ ${confirm_delete} == 'yes' ]]
                then
                    delete_feedback=$(gum spin --spinner dot --title "Deleting Task (ID-${task_id_delete})..." --show-output -- curl -L -H "application/json" -d '' "${gapps_url}?action=delete&table=Task&id=${task_id_delete}")
                    echo "Delete Status (ID-${every_id}): "$(echo "${delete_feedback}" | jq -r '.success')  
                fi
            fi

            last_run_input=${run_date_array["${every_id}"]}
            update_feedback=$(gum spin --spinner dot --title "Updating Run Time (ID-${every_id})..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"last_run\\\":\\\"${last_run_input}\\\"}\"" "${gapps_url}?action=update&table=Task&id=${every_id}")
            echo "Update Run Time Status (ID-${every_id}): "$(echo "${update_feedback}" | jq -r '.success')
        done
    fi
}

if [[ "$1" == 'pcsync' ]] # Script/Command: "pcsync"
then
    if [[ "$2" == 'help' ]]
    then
        help_pcsync
        exit
    fi

    all_device_string=""
    declare -A all_device_array
    all_task_string=""
    declare -A all_task_array
    get_device_store=""
    get_task_store=""
    if [[ (${OSTYPE} == 'msys') || (-f '/etc/wsl.conf') ]]
    then
        this_device_ip=$(ipconfig.exe | grep 'IPv4 Address' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep '192.168.0.*')
    elif [[ (${OSTYPE} == 'linux-gnu') && ($(ifconfig | grep 'wlan0') == '') ]]
    then
        this_device_ip=$(ifconfig eth0 | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1')
    else
        this_device_ip=$(ifconfig wlan0 | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1')
    fi
    work_type="$2"
    action="$3"
    criteria="$4"
    case ${work_type} in
        'device')
            case ${action} in
                'view')
                    device_view_pcsync;;
                'add')
                    device_add_pcsync;;
                'edit')
                    device_edit_pcsync;;
                'delete')
                    device_delete_pcsync;;
            esac;;
        'task')
            case ${action} in
                'view')
                    task_view_filterby_list_pcsync;;
                'sview')
                    task_view_filterby_range_pcsync;;
                'add')
                    task_add_pcsync;;
                'edit')
                    task_edit_filterby_list_pcsync;;
                'sedit')
                    task_edit_filterby_range_pcsync;;
                'delete')
                    task_delete_filterby_list_pcsync;;
                'sdelete')
                    task_delete_filterby_range_pcsync;;
                'download')
                    device_task_download_pcsync;;
                'vcmd')
                    task_run_pcsync "cmd-view" ${criteria};;
                'drun')
                    task_run_pcsync "dry-run" ${criteria};;
                'frun')
                    task_run_pcsync "final-run" ${criteria};;
                'srun')
                    task_run_pcsync "selective-run" ${criteria};;
            esac;;
    esac
    exit
fi

#----------------------------END-SCRIPT: pcsync----------------------------

#----------------------------START-SCRIPT: cmdref----------------------------

cmdref_help_text="view || View cmdref.\n
add || Add new cmdref.\n
edit || Edit existing cmdref.\n
delete || Delete existing cmdref.\n
download || Download cmdref json file.\n
c || Show all options of a cmd."

function help_cmdref() {
    printf "Usage:\njjkk pcsync [command]\n\nAvailabe Commands:\n"
    printf "${cmdref_help_text}" | column --table --separator "||"
}

function store_command_cmdref() {
    all_command_string=""
    if [[ ${OSTYPE} == 'msys' ]]
    then
        echo "Fetching Command Reference..."
        get_command_list=$(curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=CmdRef")
    else
        get_command_list=$(gum spin --spinner dot --title "Fetching Command Reference..." --show-output -- curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=CmdRef")
    fi
    get_command_list=$(escape_single_quote "${get_command_list}")

    get_command_array=$(echo "${get_command_list}" | jq -r '.data|map("
all_command_array['\''\(.id),id'\'']='\''\(.id)'\'';
all_command_array['\''\(.id),command_name'\'']='\''\(.command_name)'\'';
all_command_array['\''\(.id),command_option'\'']='\''\(.command_option)'\'';
all_command_array['\''\(.id),command_example'\'']='\''\(.command_example)'\'';
all_command_array['\''\(.id),os_platform'\'']='\''\(.os_platform)'\'';
all_command_array['\''\(.id),summary'\'']='\''\(.summary)'\'';
all_command_array['\''\(.id),description'\'']='\''\(.description)'\'';
all_command_array['\''\(.id),reference'\'']='\''\(.reference)'\'';
all_command_string+=\"\(.id)\\t\(.command_name)\\t\(.command_option)\\t\(.summary)\\n\";
")|.[]')
    eval "${get_command_array}"
    all_command_string=${all_command_string%??}
}

function command_view_cmdref() {
    store_command_cmdref
    filtered_command_string=$(echo -e ${all_command_string} | gum filter --indicator=">" --header="Select CmdRef: Command Name | Option | Summary")
    filtered_command_array=(${filtered_command_string})
    filtered_id=${filtered_command_array[0]}
    command_id_get=${all_command_array["${filtered_id},id"]}
    command_name_get=${all_command_array["${filtered_id},command_name"]}
    command_option_get=${all_command_array["${filtered_id},command_option"]}
    command_example_get=${all_command_array["${filtered_id},command_example"]}
    os_platform_get=${all_command_array["${filtered_id},os_platform"]}
    summary_get=${all_command_array["${filtered_id},summary"]}
    description_get=${all_command_array["${filtered_id},description"]}
    reference_get=${all_command_array["${filtered_id},reference"]}
    
    echo -e -n "\033[33m ID: \033[0m" && echo "${command_id_get}"
    echo -e -n "\033[33m Command Name: \033[0m" && echo "${command_name_get}"
    echo -e -n "\033[33m Command Option: \033[0m" && echo "${command_option_get}"
    echo -e -n "\033[33m Command Example: \033[0m" && echo "${command_example_get}"
    echo -e -n "\033[33m OS Platform: \033[0m" && echo "${os_platform_get}"
    echo -e -n "\033[33m Summary: \033[0m" && echo "${summary_get}"
    echo -e -n "\033[33m Description: \033[0m" && echo "${description_get}"
    echo -e -n "\033[33m Reference: \033[0m" && echo "${reference_get}"
}

function command_add_cmdref() {
    command_name_input=$(escapejc "$(gum input --header="Enter Command Name" --placeholder="Write Command Name")")
    command_option_input=$(escapejc "$(gum input --header="Enter Command Option" --placeholder="Write Command Option")")
    if [[ ${command_name_input} == ${command_option_input} ]]
    then
        command_example_input=''
    else
        command_example_input=$(escapejc "$(gum input --header="Enter Command Example" --placeholder="Write Command Example")")
    fi
    os_platform_input=$(escapejc "$(gum choose --header="Select Operating System Platform" "multiple" "linux" "windows")")
    summary_input=$(escapejc "$(gum input --header="Enter Summary" --placeholder="Write Summary")")
    description_input=$(escapejc "$(gum write --header="Enter Description" --placeholder="Write Description")")
    reference_input=$(escapejc "$(gum write --header="Enter Reference" --placeholder="Write Reference")")

    insert_feedback=$(gum spin --spinner dot --title "Adding Command Reference..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"command_name\\\":\\\"${command_name_input}\\\", \\\"command_option\\\": \\\"${command_option_input}\\\", \\\"command_example\\\":\\\"${command_example_input}\\\", \\\"os_platform\\\":\\\"${os_platform_input}\\\", \\\"summary\\\":\\\"${summary_input}\\\", \\\"description\\\":\\\"${description_input}\\\", \\\"reference\\\":\\\"${reference_input}\\\"}\"" "${gapps_url}?action=insert&table=CmdRef")
    echo "${insert_feedback}" | jq
}

function command_edit_cmdref() {
    store_command_cmdref
    filtered_command_string=$(echo -e ${all_command_string} | gum filter --indicator=">" --header="Select CmdRef: Command Name | Option | Summary")
    filtered_command_array=(${filtered_command_string})
    filtered_id=${filtered_command_array[0]}
    command_id_edit=${all_command_array["${filtered_id},id"]}
    command_name_edit=${all_command_array["${filtered_id},command_name"]}
    command_option_edit=${all_command_array["${filtered_id},command_option"]}
    command_example_edit=${all_command_array["${filtered_id},command_example"]}
    os_platform_edit=${all_command_array["${filtered_id},os_platform"]}
    summary_edit=${all_command_array["${filtered_id},summary"]}
    description_edit=${all_command_array["${filtered_id},description"]}
    reference_edit=${all_command_array["${filtered_id},reference"]}
    
    command_name_input=$(escapejc "$(gum input --header="Enter Command Name" --placeholder="Enter Command Name" --value="${command_name_edit}")")
    command_option_input=$(escapejc "$(gum input --header="Enter Command Option" --placeholder="Write Command Option" --value="${command_option_edit}")")
    if [[ ${command_name_input} == ${command_option_input} ]]
    then
        command_example_input=''
    else
        command_example_input=$(escapejc "$(gum input --header="Enter Command Example" --placeholder="Write Command Example" --value="${command_example_edit}")")
    fi
    os_platform_input=$(escapejc "$(gum choose --header="Select Operating System Platform" --selected="${os_platform_edit}" "multiple" "linux" "windows")")
    summary_input=$(escapejc "$(gum input --header="Enter Summary" --placeholder="Write Summary" --value="${summary_edit}")")
    description_input=$(escapejc "$(gum write --header="Enter Description" --placeholder="Write Description" --value="${description_edit}")")
    reference_input=$(escapejc "$(gum write --header="Enter Reference" --placeholder="Write Reference" --value="${reference_edit}")")

    update_feedback=$(gum spin --spinner dot --title "Updating Command Reference..." --show-output -- curl -L -H "application/json" --silent --no-progress-meter --form "data=\"{\\\"command_name\\\":\\\"${command_name_input}\\\", \\\"command_option\\\": \\\"${command_option_input}\\\", \\\"command_example\\\":\\\"${command_example_input}\\\", \\\"os_platform\\\":\\\"${os_platform_input}\\\", \\\"summary\\\":\\\"${summary_input}\\\", \\\"description\\\":\\\"${description_input}\\\", \\\"reference\\\":\\\"${reference_input}\\\"}\"" "${gapps_url}?action=update&table=CmdRef&id=${command_id_edit}")
    echo "${update_feedback}" | jq
}

function command_delete_cmdref() {
    store_command_cmdref
    filtered_command_string=$(echo -e ${all_command_string} | gum filter --indicator=">" --header="Select CmdRef: Command Name | Option | Summary")
    filtered_command_array=(${filtered_command_string})
    filtered_id=${filtered_command_array[0]}
    command_id_delete=${all_command_array["${filtered_id},id"]}
    command_name_delete=${all_command_array["${filtered_id},command_name"]}
    command_option_delete=${all_command_array["${filtered_id},command_option"]}
    command_example_delete=${all_command_array["${filtered_id},command_example"]}
    summary_delete=${all_command_array["${filtered_id},summary"]}
    description_delete=${all_command_array["${filtered_id},description"]}
    confirm_delete=$(gum confirm --default="No" "Delete Command Ref: ${command_name_delete} -- ${command_option_delete}?" && echo "yes" || echo "no")

    if [[ ${confirm_delete} == "yes" ]]
    then
        delete_feedback=$(gum spin --spinner dot --title "Deleting Command Reference..." --show-output -- curl -L -H "application/json" -d '' "${gapps_url}?action=delete&table=CmdRef&id=${command_id_delete}")
        echo "${delete_feedback}" | jq
    fi
}

function command_download_cmdref() {
    if [[ "$OSTYPE" == 'msys' ]]
    then
        echo "Downloading Command Reference..."
        get_command_list=$(curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=CmdRef")
    else
        get_command_list=$(gum spin --spinner dot --title "Downloading Command Reference..." --show-output -- curl -L -H --silent --no-progress-meter -d '' "${gapps_url}?action=read&table=CmdRef")
    fi
    echo "${get_command_list}" | jq '.data' > "${command_reference_file}"
    echo "Command Reference Downloaded."
}

function command_run_cmdref() {
    if [ ! -f "${command_reference_file}" ]; then
        command_download_cmdref
    fi

    if [[ ($1 != '') && ($2 == '') ]]
    then
        command_file_json=$(cat "${command_reference_file}" | jq ".[] | select(.command_name == \"$1\")" | jq -s .)
    elif [[ ($1 != '') && ($2 != '') ]]
    then
        command_file_json=$(cat "${command_reference_file}" | jq ".[] | select(.command_name == \"$1\") | select(.command_option == \"$2\")" | jq -s .)
    else
        command_file_json=$(cat "${command_reference_file}" | jq ".[] | select(.command_name == .command_option)" | jq -s .)
    fi
    
    if [[ ${command_file_json} == '[]' ]]
    then
        echo "No Result Found!"
        exit
    fi
    
    all_command_string=""
    get_command_list=$(escape_single_quote "${command_file_json}")
    get_command_array=$(echo "${get_command_list}" | jq -r '.|map("
all_command_array['\''\(.id),id'\'']='\''\(.id)'\'';
all_command_array['\''\(.id),command_name'\'']='\''\(.command_name)'\'';
all_command_array['\''\(.id),command_option'\'']='\''\(.command_option)'\'';
all_command_array['\''\(.id),command_example'\'']='\''\(.command_example)'\'';
all_command_array['\''\(.id),os_platform'\'']='\''\(.os_platform)'\'';
all_command_array['\''\(.id),summary'\'']='\''\(.summary)'\'';
all_command_array['\''\(.id),description'\'']='\''\(.description)'\'';
all_command_array['\''\(.id),reference'\'']='\''\(.reference)'\'';
all_command_string+=\"\(.id)\\t\(.command_name)\\t\(.command_option)\\t\(.summary)\\n\";
")|.[]')
    eval "${get_command_array}"
    all_command_string=${all_command_string%??}

    filtered_command_string=$(echo -e ${all_command_string} | gum filter --indicator=">" --header="Select CmdRef: Command Name | Option | Summary")
    filtered_command_array=(${filtered_command_string})
    filtered_id=${filtered_command_array[0]}
    command_id_get=${all_command_array["${filtered_id},id"]}
    command_name_get=${all_command_array["${filtered_id},command_name"]}
    command_option_get=${all_command_array["${filtered_id},command_option"]}
    command_example_get=${all_command_array["${filtered_id},command_example"]}
    os_platform_get=${all_command_array["${filtered_id},os_platform"]}
    summary_get=${all_command_array["${filtered_id},summary"]}
    description_get=${all_command_array["${filtered_id},description"]}
    reference_get=${all_command_array["${filtered_id},reference"]}

    if [[ (${command_name_get} == ${command_option_get}) && ($1 == '') && ($2 == '') ]]
    then
        eval $0 cmd c "${command_name_get}"
        exit
    fi

    echo -e -n "\033[33mCommand Name: \033[0m" && echo "${command_name_get}"
    echo -e -n "\033[33mCommand Option: \033[0m" && echo "${command_option_get}"
    echo -e -n "\033[33mOS Platform: \033[0m" && echo "${os_platform_get}"
    echo -e -n "\033[33mSummary: \033[0m" && echo "${summary_get}"
    echo -e -n "\033[33mDescription: \033[0m"
    if [[ ${description_get} != '' ]]; then echo ''; fi
    echo -e "${description_get}"
    echo -e -n "\033[33mReference: \033[0m"
    if [[ ${reference_get} != '' ]]; then echo ''; fi
    echo -e "${reference_get}"
    if [[ ${command_name_get} != ${command_option_get} ]]
    then
        command_example_input=$(escapejc "$(gum write --header="Enter Command To Execute" --placeholder="Write Command To Execute" --value="${command_example_get}")")
        echo -e "\033[1;32m>>>\033[0m ${command_example_input}"
        if [[ (${OSTYPE} == 'linux-gnu') && ((${os_platform_get} == 'linux') || (${os_platform_get} == 'multiple')) ]]
        then
            eval "${command_example_input}"
        elif [[ (${OSTYPE} == 'msys') && ((${os_platform_get} == 'windows') || (${os_platform_get} == 'multiple')) ]]
        then
            eval "${command_example_input}"
        else
            echo -e "\033[1;31m Command Is Not Supported In \"${OSTYPE}\" Platform! \033[0m"
        fi
    fi
}

if [[ "$1" == "cmd" ]] # Script/Command: "cmdref"
then
    if [[ "$2" == "help" ]]
    then
        help_cmdref
        exit
    fi

    all_command_string=""
    declare -A all_command_array
    work_type="$2"
    case ${work_type} in
        'view')
            command_view_cmdref;;
        'add')
            command_add_cmdref;;
        'edit')
            command_edit_cmdref;;
        'delete')
            command_delete_cmdref;;
        'download')
            command_download_cmdref;;
        'c')
            command_run_cmdref "$3" "$4";;
    esac
    exit
fi

#----------------------------END-SCRIPT: cmdref----------------------------

# all_script_cmd="rsgit || Restic and Git based backup\n
# rsdrive || Restic backup on Portable Storage Device\n
# rssync || Sync online restic repo to local-pc restic repo\n
# rsrestore || Restore single/all restic and git repository\n
# gist || GitHub-Gist management script\n
# note || Project's markdown-note management\n
# dbsync || Sync database between online and local-pc in bi-directional way\n
# dbackup || Backup database structure, data, full-db for git commit
# "
# rsgit_option=""

run_cmd_script=""
script_cmd_string=$(echo -e ${overall_help_text} | gum filter --indicator=">" --header="Select Script: Command | Summary")
script_cmd_array=(${script_cmd_string})
script_cmd=${script_cmd_array[0]}
run_cmd_script+="${script_cmd}"
case ${script_cmd} in
    'config')
        script_opt_string=$(echo -e ${config_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        case ${script_opt} in
            'rbase')
                script_arg_string=$(echo -e ${config_rbase_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
            'repo')
                script_arg_string=$(echo -e ${config_repo_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
            'download')
                script_arg_string=$(echo -e ${config_download_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
            'import')
                script_arg_string=$(echo -e ${config_import_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
        esac
        run_cmd_script+=" ${script_arg}"
        ;;
    'rsgit')
        script_opt_string=$(echo -e ${rsgit_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        ;;
    'rsdrive')
        script_opt_string=$(echo -e ${rsdrive_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        ;;
    'rssync')
        script_opt_string=$(echo -e ${rssync_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        ;;
    'rsrestore')
        script_opt_string="";;
    'gist')
        script_opt_string=$(echo -e ${ghgist_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        ;;
    'note')
        script_opt_string=$(echo -e ${pjnote_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        ;;
    'todo')
        script_opt_string=$(echo -e ${pjtodo_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        case ${script_opt} in
            'project')
                script_arg_string=$(echo -e ${pjtodo_project_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
            'record')
                script_arg_string=$(echo -e ${pjtodo_record_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
            'attachment')
                script_arg_string=$(echo -e ${pjtodo_attachment_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
            'comment')
                script_arg_string=$(echo -e ${pjtodo_comment_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
        esac
        run_cmd_script+=" ${script_arg}"
        ;;
    'dbsync')
        script_opt_string=$(echo -e ${dbsync_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        ;;
    'dbackup')
        script_opt_string=$(echo -e ${dbackup_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        ;;
    'pcsync')
        script_opt_string=$(echo -e ${pcsync_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        case ${script_opt} in
            'device')
                script_arg_string=$(echo -e ${pcsync_device_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
            'task')
                script_arg_string=$(echo -e ${pcsync_task_help} | gum filter --indicator=">" --header="Select Argument For ${script_opt} (${script_cmd}): Argument | Summary")
                script_arg_array=(${script_arg_string})
                script_arg=${script_arg_array[0]}
                ;;
        esac
        run_cmd_script+=" ${script_arg}"
        ;;
    'cmd')
        script_opt_string=$(echo -e ${cmdref_help_text} | gum filter --indicator=">" --header="Select Option For ${script_cmd}: Option | Summary")
        script_opt_array=(${script_opt_string})
        script_opt=${script_opt_array[0]}
        run_cmd_script+=" ${script_opt}"
        ;;
    'exit')
        exit
esac

# echo ${run_cmd_script}
eval $0 ${run_cmd_script}
